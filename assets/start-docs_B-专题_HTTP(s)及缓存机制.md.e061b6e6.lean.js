import{_ as i,r as t,i as e,a}from"./chunks/framework.bb8f9838.js";const o="/assets/四次挥手.a670be5c.png",p=JSON.parse('{"title":"TCP/IP","description":"","frontmatter":{},"headers":[{"level":2,"title":"四层协议","slug":"四层协议","link":"#四层协议","children":[]},{"level":2,"title":"OSI七层模型","slug":"osi七层模型","link":"#osi七层模型","children":[]},{"level":2,"title":"HTTP","slug":"http","link":"#http","children":[]},{"level":2,"title":"浏览器缓存","slug":"浏览器缓存","link":"#浏览器缓存","children":[]},{"level":2,"title":"HTTPS加密","slug":"https加密","link":"#https加密","children":[{"level":3,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}]}],"relativePath":"start-docs/B-专题/HTTP(s)及缓存机制.md","filePath":"start-docs/B-专题/HTTP(s)及缓存机制.md"}'),r={name:"start-docs/B-专题/HTTP(s)及缓存机制.md"};function n(s,l,u,h,c,T){return t(),e("div",null,l[0]||(l[0]=[a('<h1 id="tcp-ip" tabindex="-1">TCP/IP <a class="header-anchor" href="#tcp-ip" aria-label="Permalink to &quot;TCP/IP&quot;">​</a></h1><p><img src="'+o+'" alt="&quot;四次挥手&quot;"></p><h2 id="四层协议" tabindex="-1">四层协议 <a class="header-anchor" href="#四层协议" aria-label="Permalink to &quot;四层协议&quot;">​</a></h2><ul><li>应用层 HTTP FTP Telnet</li><li>传输层 TCP/UDP</li><li>网络层 IP ICMP IGMP</li><li>数据链路层 ARP</li></ul><h2 id="osi七层模型" tabindex="-1">OSI七层模型 <a class="header-anchor" href="#osi七层模型" aria-label="Permalink to &quot;OSI七层模型&quot;">​</a></h2><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h2 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h2><ul><li>HTTP1.1协议（rfc规定的协议） <ul><li>基于TCP协议</li><li>请求分为： <ul><li>请求行（method,path,version) eg: POST /chapther/user.html HTTP/1.1</li><li>请求头(accept,accept-encoding, accept-language,cache-control, connection,host,<strong>if-modified-since</strong>,<strong>if-none-match</strong>, user-agent, cookie)</li><li>请求体,请求参数 <ul><li>application/json</li><li>application/x-www-form-urlencoded 表单数据默认行为</li><li>multipart/form-data 上传文件常用</li><li>text/html</li></ul></li></ul></li><li>响应与请求类似 <ul><li>响应头（cache-control,connection, content-encoding, content-length, content-type, date, <strong>etag</strong>, expires, keep-alive, <strong>last-modified</strong>, server, set-cookie, via(服务端请求链路)）</li></ul></li><li>HTTP status code <ul><li>1xx 临时回应，表示客户端继续，被浏览器http库直接处理</li><li>2xx 请求成功系列 例如：200</li><li>3xx 请求目标有变化，希望客户端进一步处理 301&amp;302 304(<strong>重点</strong>)</li><li>4xx 客户端请求错误 401未授权 403 Forbidden 拒绝访问 404页面不存在</li><li>5xx 服务端请求错误 500服务端错误 503服务端暂时性错误，可以一会再试</li></ul></li><li>HTTPS协议 <ul><li>使用加密通道来传输http的内容。首先与服务端建立TLS加密通道。</li><li>TLS构建于TCP协议之上</li></ul></li><li>HTTP2.0 （1.1的升级） <ul><li>支持服务端推送， 可以在收到第一个请求到服务端时，提前将一部分内容推送给客户端放入缓存</li><li>支持TCP连接复用， 可以把使用同一个tcp来传输多个http请求，避免tcp连接建立时的三次握手开销</li></ul></li><li>HTTP3.0 <ul><li>http本质还是tcp,还是会遇到对头阻塞问题，谷歌提出QUIC协议，基于UDP</li><li>HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制。</li></ul></li></ul></li><li>GET和POST请求本质和区别</li></ul><h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h2><ul><li>强缓存（HTTP状态码返回200） <ul><li>Pragma(优先级高于Cache-control) http1.0的标准 <ul><li>no-cache</li></ul></li><li>Expires 设置缓存过期时间 1.0的标准</li><li>Cache-control http1.1的标准 <ul><li>no-store 所有内容都不缓存</li><li>no-cache 缓存，但是需要通过与服务器进行通信判断该资源是否为最新。若未过期，则返回304</li><li>max-age 设置缓存最大周期，时间是相对于请求的时间。(优先级高于expires)</li><li>public 可以被任何中间人缓存</li><li>private 中间人不能缓存此响应</li></ul></li><li>浏览器返回200状态有两种情况 <ul><li>from memory cache 从内存中获取，一般缓存更新频率较高的js、图片、字体等资源,当资源从内存中释放，就会从磁盘中获取。</li><li>from disk cache 从磁盘中过去，一般缓存更新频率较低的js、css等资源</li></ul></li></ul></li><li>协商缓存HTTP状态码返回304） <ul><li>Last-modified/If-Modified-Since (http1.0) Last-Modified是个时间戳，只能精确到秒</li><li>Etag/If-None-Match (http1.1)（（优先级高） <ul><li>etag的生成规则 在nginx中是由：last-modified + content-length 十六进制组合而成</li></ul></li></ul></li><li>优劣势 <ul><li>expires <ul><li>时间有服务器发送，如果服务器和客户端时间存在不一致，可能出现问题。</li><li>存在版本问题，到期之前的修改客户端是不可知的</li></ul></li><li>cache-control <ul><li>http1.1才能用，不适合1.0</li><li>存在版本问题，到期之前的修改客户端是不可知的</li></ul></li><li>last-modified <ul><li>只要资源修改，不论资源是否发生变化，例如周期性重写，都会导致无效更新</li><li>以时间作为标识，只能精准到秒级别，无法判断1s内进行多次修改</li><li>某些服务器不能精准得到文件最后修改时间</li></ul></li><li>etag <ul><li>计算etag需要性能损耗</li><li>分布式服务器存储情况下，可能计算etag算法不一致导致无法匹配</li></ul></li></ul></li><li>优先使用强缓存，协商缓存会与服务器进行一次通信</li><li>缓存优先级 强缓存&gt;etag&gt;last-modified</li><li>max-age和expires一般会写两个，为了向下兼容。在1.1环境中，max-age优先级高于expires</li></ul><h2 id="https加密" tabindex="-1">HTTPS加密 <a class="header-anchor" href="#https加密" aria-label="Permalink to &quot;HTTPS加密&quot;">​</a></h2><ul><li>参考链接[<a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/43789231</a>]</li><li>内容加密： 采用混合加密技术，中间者无法直接查看明文内容</li><li>验证身份： 通过证书认证客户端访问的是自己的服务器</li><li>保护数据完整性： 防止传输的内容被中间人冒充或者篡改</li><li>加密方式 <ul><li>对称加密： 加密和解密用同一个秘钥。 <ul><li>算法简单，加密容易，效率高</li><li>相对不安全，密文被拦截切秘钥被劫持，容易被破译</li></ul></li><li>非对称加密：加密用公钥，解密用私钥。公钥和私钥是成对存在。通过私钥可以推导出公钥，但是通过公钥无法推导出私钥。 <ul><li>安全，互相保管不同的密钥</li><li>加密算法复杂，安全依赖算法和密钥，效率相对较低</li></ul></li><li>双非对称加密方式，使用两组公钥私钥。服务器保存公钥A和私钥B,浏览器保存公钥B和私钥A。传输数据是传输方用自己的公钥加密，接收方用对应的私钥解密。的确加强了安全性，但是非对称加密算法非常耗时。不划算。</li><li>非对称和对称加密结合。服务器将公钥A发送浏览器，浏览器随机生成一个用于对称加密的秘钥X,将秘钥X使用公钥A加密后传给服务器，服务器通过私钥A解密，就可以得到对称秘钥X。之后就用X进行加解密。--但是，还是会被中间人攻击获取。中间人可以劫持服务器发送给浏览器的公钥A,伪造自己准备的公钥B给浏览器。浏览器通过公钥B加密对称X后继续被劫持，这样就得到对称秘钥X。</li><li>HTTPS（SSL/TLS)加密：对称加密、非对称加密、数字签名、数字证书。 <ul><li>如何保证浏览器的收到的公钥是服务器传输的公钥？利用身份证类似的&quot;公信&quot;作用，找第三方颁发证书。</li><li>HTTPS 可以理解为HTTP+TLS(前身是SSL)</li><li>先向CA机构申请颁发一份数字证书。数字证书中包含：域名、证书持有者、证书持有者的公钥等。</li><li>为防止证书在传输过程中被篡改，增加数字证书防伪，即数字签名。 <ul><li>数字签名的过程： <ul><li>CA拥有非对称加密的私钥和公钥</li><li>CA对证书明文信息进行hash</li><li>对hash后的值用私钥进行加密，得到数字签名</li><li>明文和数字签名共同组成了数字证书。</li></ul></li></ul></li><li>浏览器验证过程： <ul><li>拿到证书，得到明文T,数字签名S。</li><li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以保有公钥），得到S‘。</li><li>用证书里说明的hash算法对明文T进行hash得到T’。</li><li>比较S‘是否等于T’。等于则表明证书可信。</li></ul></li></ul></li></ul></li></ul><h3 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h3><ul><li>[<a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noreferrer">https://www.jianshu.com/p/54cc04190252</a>] 深入浏览器缓存机制</li></ul>',14)]))}const P=i(r,[["render",n]]);export{p as __pageData,P as default};
