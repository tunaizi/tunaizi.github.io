import{_ as n,r as s,i as a,a as o}from"./chunks/framework.8a6edf47.js";const y=JSON.parse('{"title":"管理作用域","description":"","frontmatter":{},"headers":[{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[]},{"level":2,"title":"对象","slug":"对象","link":"#对象","children":[]},{"level":2,"title":"函数执行过程","slug":"函数执行过程","link":"#函数执行过程","children":[]},{"level":2,"title":"闭包、作用域和内存","slug":"闭包、作用域和内存","link":"#闭包、作用域和内存","children":[]},{"level":2,"title":"对象成员","slug":"对象成员","link":"#对象成员","children":[]},{"level":2,"title":"null undefined 等特殊性质","slug":"null-undefined-等特殊性质","link":"#null-undefined-等特殊性质","children":[]}],"relativePath":"start-docs/studyhard/1专题/JS作用域.md","filePath":"start-docs/studyhard/1专题/JS作用域.md"}'),e={name:"start-docs/studyhard/1专题/JS作用域.md"};function t(i,l,p,r,c,u){return s(),a("div",null,l[0]||(l[0]=[o(`<h1 id="管理作用域" tabindex="-1">管理作用域 <a class="header-anchor" href="#管理作用域" aria-label="Permalink to &quot;管理作用域&quot;">​</a></h1><ul><li>数据存储共有 4 中方式： 字面量、变量、数组项、对象成员。</li><li>访问字面量和局部变量速度最快，访问数组元素和对象成员较慢。</li><li>全局变量总出在作用域链的最末端，访问速度总是比局部变量慢。</li></ul><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><ul><li>每一个 js 函数都表示为一个对象，更确切的说，是 Function 对象的实例。</li></ul><h2 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h2><ul><li>对象拥有可以访问的属性和只能 js 引擎存取的内部属性。</li><li>[[scope]]：就是内部属性。包含了一个函数被创建的作用域中对象的集合。</li></ul><h2 id="函数执行过程" tabindex="-1">函数执行过程 <a class="header-anchor" href="#函数执行过程" aria-label="Permalink to &quot;函数执行过程&quot;">​</a></h2><ul><li>创建一个执行环境的内部对象</li><li>初始化作用域链，将当前运行函数的[[scope]]的属性复制到执行环境的作用域链中，并推入到作用域链最前端。 这个新对象就是活动对象。</li><li>会经历标识符解析过程，该过程就是搜索执行环境的作用域链。会一直向下查找，直到找不到就会认为未定义。</li><li>这个过程会影响性能。固然尽可能使用局部变量。</li><li>改变作用域链有两种方式，with 及 try-catch,catch 会将异常对象推入一个变量对象并放在作用域最前端，函数的局部变量会放在第二个作用域对象中。当执行 catch 完成后，就会返回之前的状态。</li><li>动态作用域链（with,try-catch,eval)。只存在代码执行过程中，无法通过静态分析检测。</li></ul><h2 id="闭包、作用域和内存" tabindex="-1">闭包、作用域和内存 <a class="header-anchor" href="#闭包、作用域和内存" aria-label="Permalink to &quot;闭包、作用域和内存&quot;">​</a></h2><ul><li>闭包：本质就是一个绑定了执行环境的函数 <ul><li>允许函数访问局部作用域之外的数据。</li><li>闭包创建时[[scope]]属性对象和执行环境作用域链的对象引用是相同的。在函数执行完成后，活动对象本来会销毁，但是由于与闭包内的引用还存在闭包[[scope]]中，故而不会销毁。闭包会增加内存开销。</li></ul></li></ul><h2 id="对象成员" tabindex="-1">对象成员 <a class="header-anchor" href="#对象成员" aria-label="Permalink to &quot;对象成员&quot;">​</a></h2><ul><li>原型 <ul><li>js 中的对象是基础原型的。它定义并实现了一个新创建的对象必须包含的成员列表。</li><li>所有实例对象都共享原型对象的成员。</li><li>对象通过一个内部属性绑定到它的原型（<strong>proto</strong>）。一旦创建了一个内置对象（Object 和 Array）的实例，就自动拥有一个 Object 实例作为原型。</li><li>实例对象的(<strong>proto</strong>) -&gt; Object.prototype</li><li>一个实例对象可以有两种成员类型：实例成员（也成为 own 成员）和原型成员。</li><li>hasOwnProperty()就是用来判断对象是否包含特定的实例成员。</li><li>key in object 可以判断所有成员 eg: &#39;toString&#39; in book //true <strong>in 操作既会搜索实例成员也会搜索原型成员</strong></li></ul></li><li>原型链 <ul><li>所有对象都是对象（Object）的实例。并继承了所有方法。eg： Function instanceof Object //true。除了 null 和 undefined 不是 Object 的实例</li><li>经典例子：<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Book</span><span style="color:#E1E4E8;">(){} </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> book </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Book</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  book.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Book</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">Book</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">__proto__</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">====</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span></code></pre></div></li></ul></li></ul><h2 id="null-undefined-等特殊性质" tabindex="-1">null undefined 等特殊性质 <a class="header-anchor" href="#null-undefined-等特殊性质" aria-label="Permalink to &quot;null undefined 等特殊性质&quot;">​</a></h2><ul><li><p>typeof null //object</p></li><li><p>typeof undefined // undefined</p></li><li><p>typeof NaN // number</p></li><li><p>typeof Function // &quot;function&quot;</p></li><li><p>typeof Array // &quot;function&quot;</p></li><li><p>typeof Object // &quot;function&quot;</p></li><li><p>typeof Number // &quot;function&quot;</p></li><li><p>typeof String // &quot;function&quot;</p></li><li><p>null instanceof Object //false</p></li><li><p>NaN instanceof Object //false</p></li><li><p>undefined instanceof Object //false</p></li><li><p>Function instanceof Object //true</p></li><li><p>Array instanceof Object //true</p></li><li><p>Array instanceof Function //true</p></li><li><p>String instanceof Function //true</p></li><li><p>String instanceof Object //true</p></li></ul>`,14)]))}const E=n(e,[["render",t]]);export{y as __pageData,E as default};
