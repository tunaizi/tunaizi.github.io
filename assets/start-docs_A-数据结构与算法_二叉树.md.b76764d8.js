import{_ as n,r as l,i as a,a as p}from"./chunks/framework.bb8f9838.js";const o="/assets/ercha.5599a685.png",e="/assets/qianxu.a9d270c5.png",t="/assets/zhongxu.bcc3c593.png",E="/assets/houxu.cecd0e0c.png",B=JSON.parse('{"title":"二叉树","description":"","frontmatter":{},"headers":[{"level":2,"title":"二叉树的定义","slug":"二叉树的定义","link":"#二叉树的定义","children":[]},{"level":2,"title":"二叉树的性质","slug":"二叉树的性质","link":"#二叉树的性质","children":[]},{"level":2,"title":"二叉树的类型","slug":"二叉树的类型","link":"#二叉树的类型","children":[]},{"level":2,"title":"树是特殊的图形 验证二叉搜索树","slug":"树是特殊的图形-验证二叉搜索树","link":"#树是特殊的图形-验证二叉搜索树","children":[]},{"level":2,"title":"二叉树的最近公共祖先","slug":"二叉树的最近公共祖先","link":"#二叉树的最近公共祖先","children":[]},{"level":2,"title":"二叉树遍历","slug":"二叉树遍历","link":"#二叉树遍历","children":[]},{"level":2,"title":"什么是波兰表达式","slug":"什么是波兰表达式","link":"#什么是波兰表达式","children":[]}],"relativePath":"start-docs/A-数据结构与算法/二叉树.md","filePath":"start-docs/A-数据结构与算法/二叉树.md"}'),r={name:"start-docs/A-数据结构与算法/二叉树.md"};function c(y,s,i,F,u,d){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h1><h2 id="二叉树的定义" tabindex="-1">二叉树的定义 <a class="header-anchor" href="#二叉树的定义" aria-label="Permalink to &quot;二叉树的定义&quot;">​</a></h2><p>二叉树是一种特殊的树结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树在计算机科学中有广泛的应用，包括数据存储、查找和排序等。 二叉树是一种递归定义的数据结构。一棵二叉树可以是空的，或者由一个根节点和两棵互不相交的左子树和右子树组成。</p><h2 id="二叉树的性质" tabindex="-1">二叉树的性质 <a class="header-anchor" href="#二叉树的性质" aria-label="Permalink to &quot;二叉树的性质&quot;">​</a></h2><ol><li><p><strong>节点数</strong>:</p><ul><li>如果一棵二叉树的深度为 h，则该二叉树最多有 (2^h - 1) 个节点。</li><li>如果一棵二叉树有 n 个节点，则其深度至少为 (\\lceil \\log_2(n+1) \\rceil)。</li></ul></li><li><p><strong>满二叉树</strong>:</p><ul><li>所有层都被完全填满的二叉树。</li></ul></li><li><p><strong>完全二叉树</strong>:</p><ul><li>除了最后一层外，其他层都被完全填满，并且最后一层的节点都尽可能靠左。</li></ul></li></ol><h2 id="二叉树的类型" tabindex="-1">二叉树的类型 <a class="header-anchor" href="#二叉树的类型" aria-label="Permalink to &quot;二叉树的类型&quot;">​</a></h2><ol><li><p><strong>满二叉树</strong>:</p><ul><li>所有层都被完全填满的二叉树。</li></ul></li><li><p><strong>完全二叉树</strong>:</p><ul><li>除了最后一层外，其他层都被完全填满，并且最后一层的节点都尽可能靠左。</li></ul></li><li><p><strong>平衡二叉树</strong>:</p><ul><li>每个节点的左右子树的高度差不超过 1。</li></ul></li></ol><p><strong>图形就是含有环形的链表，常用判断最优路径</strong></p><h2 id="树是特殊的图形-验证二叉搜索树" tabindex="-1">树是特殊的图形 验证二叉搜索树 <a class="header-anchor" href="#树是特殊的图形-验证二叉搜索树" aria-label="Permalink to &quot;树是特殊的图形 验证二叉搜索树&quot;">​</a></h2><ul><li>做一次中序遍历 时间复杂度 o(n)<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValisBST</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> stack </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> inorder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">Infinity</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      stack.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(root)</span></span>
<span class="line"><span style="color:#E1E4E8;">      root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.left</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root.val </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> inorder) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    inorder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.val</span></span>
<span class="line"><span style="color:#E1E4E8;">    root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.right</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li>递归 时间复杂度 o(n)<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">min</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">Infinity</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">max</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Infinity</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    root </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">    (root.val </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> min </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      root.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> max </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(root.left, min, root.val) </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(root.right, root.val, max))</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li></ul><h2 id="二叉树的最近公共祖先" tabindex="-1">二叉树的最近公共祖先 <a class="header-anchor" href="#二叉树的最近公共祖先" aria-label="Permalink to &quot;二叉树的最近公共祖先&quot;">​</a></h2><p>在二叉树中查找两个节点的最近公共祖先，可以使用递归的方法。具体步骤如下：</p><ol><li>如果当前节点为空，返回 <code>null</code>。</li><li>如果当前节点是 <code>p</code> 或 <code>q</code>，返回当前节点。</li><li>递归查找左子树和右子树。</li><li>如果左子树和右子树都找到了 <code>p</code> 或 <code>q</code>，则当前节点为最近公共祖先。</li><li>如果只有一边找到了 <code>p</code> 或 <code>q</code>，则返回找到的那个节点。</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lowestCommonAncestor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">p</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">q</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> q) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">left</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lowestCommonAncestor</span><span style="color:#E1E4E8;">(root.left, p, q)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">right</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lowestCommonAncestor</span><span style="color:#E1E4E8;">(root.right, p, q)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root </span><span style="color:#6A737D;">// p 和 q 分别在左右子树中</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> right </span><span style="color:#6A737D;">// 返回非空的子树结果</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="二叉树遍历" tabindex="-1">二叉树遍历 <a class="header-anchor" href="#二叉树遍历" aria-label="Permalink to &quot;二叉树遍历&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">binaryTree</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  C: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#9ECBFF;">&#39;A&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#9ECBFF;">&#39;F&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  A: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#9ECBFF;">&#39;B&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  B: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#9ECBFF;">&#39;G&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  F: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#9ECBFF;">&#39;E&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#9ECBFF;">&#39;H&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  E: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  H: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  G: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 定义一个函数将扁平化结构转换为嵌套结构</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">flattenToNested</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">binaryTree</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">rootKey</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">binaryTree[rootKey]) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">node</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> binaryTree[rootKey]</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    value: rootKey,</span></span>
<span class="line"><span style="color:#E1E4E8;">    left: </span><span style="color:#B392F0;">flattenToNested</span><span style="color:#E1E4E8;">(binaryTree, node.left),</span></span>
<span class="line"><span style="color:#E1E4E8;">    right: </span><span style="color:#B392F0;">flattenToNested</span><span style="color:#E1E4E8;">(binaryTree, node.right)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">JSON</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">flattenToNested</span><span style="color:#E1E4E8;">(binaryTree, </span><span style="color:#9ECBFF;">&#39;C&#39;</span><span style="color:#E1E4E8;">), </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;C&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;A&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;B&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;G&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;F&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;E&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;value&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;H&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;left&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#9ECBFF;">&quot;right&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+o+`" alt="二叉树"></p><ol><li><p><strong>前序遍历（Pre-order）</strong>:</p><ul><li>顺序：根节点 -&gt; 左子树 -&gt; 右子树。</li><li>优势：适用于复制树结构，生成前缀表达式。</li><li>劣势：不适合查找特定节点。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preOrderTraversal</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">node</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(node.value) </span><span style="color:#6A737D;">// 访问根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">preOrderTraversal</span><span style="color:#E1E4E8;">(node.left) </span><span style="color:#6A737D;">// 遍历左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">preOrderTraversal</span><span style="color:#E1E4E8;">(node.right) </span><span style="color:#6A737D;">// 遍历右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li></ol><p><img src="`+e+`" alt="二叉树前序遍历"></p><ol start="2"><li><p><strong>中序遍历（In-order）</strong>:</p><ul><li>顺序：左子树 -&gt; 根节点 -&gt; 右子树。</li><li>优势：对于二叉搜索树（BST），按升序访问节点。</li><li>劣势：不适合查找特定节点。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">inOrderTraversal</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">node</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">inOrderTraversal</span><span style="color:#E1E4E8;">(node.left) </span><span style="color:#6A737D;">// 遍历左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(node.value) </span><span style="color:#6A737D;">// 访问根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">inOrderTraversal</span><span style="color:#E1E4E8;">(node.right) </span><span style="color:#6A737D;">// 遍历右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+t+`" alt="二叉树中序遍历"></p></li><li><p><strong>后序遍历（Post-order）</strong>:</p><ul><li>顺序：左子树 -&gt; 右子树 -&gt; 根节点。</li><li>优势：适用于删除树结构，生成后缀表达式。</li><li>劣势：不适合查找特定节点。</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrderTraversal</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">node</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">postOrderTraversal</span><span style="color:#E1E4E8;">(node.left) </span><span style="color:#6A737D;">// 遍历左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">postOrderTraversal</span><span style="color:#E1E4E8;">(node.right) </span><span style="color:#6A737D;">// 遍历右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(node.value) </span><span style="color:#6A737D;">// 访问根节点</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+E+'" alt="二叉树后序遍历"></p></li></ol><ul><li>常用： 广度优先遍历&amp;深度优先遍历</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;"></span></span></code></pre></div><h2 id="什么是波兰表达式" tabindex="-1">什么是波兰表达式 <a class="header-anchor" href="#什么是波兰表达式" aria-label="Permalink to &quot;什么是波兰表达式&quot;">​</a></h2><p>波兰表达式也称为前缀表达式，逆波兰表达式也称为后缀表达式。以表达式 (1 + 2) * (3 + 4) 为例，这个表达式称为中缀表达式。</p><table><thead><tr><th style="text-align:left;">表达</th><th style="text-align:left;">描述</th><th style="text-align:center;">结果</th></tr></thead><tbody><tr><td style="text-align:left;">前缀表达式</td><td style="text-align:left;">不含括号的的算数表达式，将运算符写在前面，操作数写在后面</td><td style="text-align:center;">* + 1 2 + 3 4</td></tr><tr><td style="text-align:left;">中缀表达式</td><td style="text-align:left;">必须含括号，操作符处于操作数的中间</td><td style="text-align:center;">( 1 + 2 ) * ( 3 + 4 )</td></tr><tr><td style="text-align:left;">后缀表达式</td><td style="text-align:left;">不含括号，运算符放在两个运算对象的后面。</td><td style="text-align:center;">1 2 + 3 4 + *</td></tr></tbody></table><p>参考链接：[<a href="https://blog.csdn.net/zcs425171513/article/details/118310303" target="_blank" rel="noreferrer">https://blog.csdn.net/zcs425171513/article/details/118310303</a>]</p>',26)]))}const h=n(r,[["render",c]]);export{B as __pageData,h as default};
