import{_ as a,r as n,i as l,a as o}from"./chunks/framework.d927199b.js";const F=JSON.parse('{"title":"树&二叉树&二叉搜索树","description":"","frontmatter":{},"headers":[],"relativePath":"start-docs/studyhard/数据结构与算法/树.md","filePath":"start-docs/studyhard/数据结构与算法/树.md"}'),p={name:"start-docs/studyhard/数据结构与算法/树.md"};function t(e,s,r,E,c,y){return n(),l("div",null,s[0]||(s[0]=[o(`<h1 id="树-二叉树-二叉搜索树" tabindex="-1">树&amp;二叉树&amp;二叉搜索树 <a class="header-anchor" href="#树-二叉树-二叉搜索树" aria-label="Permalink to &quot;树&amp;二叉树&amp;二叉搜索树&quot;">​</a></h1><ul><li>链表是特殊的树</li><li>树是特殊的图形 *** 图形就是含有环形的链表，常用判断最优路径 ***</li></ul><ol><li>验证二叉搜索树</li></ol><ul><li>做一次中序遍历 时间复杂度o(n)<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValisBST</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> stack </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> inorder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">Infinity</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(root </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        stack.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(root)</span></span>
<span class="line"><span style="color:#E1E4E8;">        root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.left</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(root.val </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> inorder) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      inorder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.val</span></span>
<span class="line"><span style="color:#E1E4E8;">      root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.right</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre></div></li><li>递归 时间复杂度o(n)<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">min</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">Infinity</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">max</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Infinity</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> root.val </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> min </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> root.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> max </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(root.left, min, root.val) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(root.right, root.val, max)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre></div></li></ul><ol start="2"><li>二叉树&amp;二叉搜索树的最近公共祖先</li><li>二叉树遍历</li></ol><ul><li>前序pre-order 根-左-右</li><li>中序In-order 左-根-右</li><li>后序Post-order 左-右-根</li><li>常用： 广度优先遍历&amp;深度优先遍历</li></ul>`,6)]))}const d=a(p,[["render",t]]);export{F as __pageData,d as default};
