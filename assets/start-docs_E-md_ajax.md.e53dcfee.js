import { _ as _export_sfc, b as r3, c as it, S as ig } from "./chunks/framework.9c9a3542.js";
const __pageData = JSON.parse('{"title":"AJAX","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是Ajax？","slug":"什么是ajax","link":"#什么是ajax","children":[{"level":3,"title":"AJAX产生的背景：","slug":"ajax产生的背景","link":"#ajax产生的背景","children":[]},{"level":3,"title":"AJAX解决的问题：","slug":"ajax解决的问题","link":"#ajax解决的问题","children":[]}]},{"level":2,"title":"创建Ajax核心对象","slug":"创建ajax核心对象","link":"#创建ajax核心对象","children":[]},{"level":2,"title":"建立连接","slug":"建立连接","link":"#建立连接","children":[]},{"level":2,"title":"发起请求","slug":"发起请求","link":"#发起请求","children":[]},{"level":2,"title":"接收响应","slug":"接收响应","link":"#接收响应","children":[]},{"level":2,"title":"GET和POST","slug":"get和post","link":"#get和post","children":[{"level":3,"title":"Ajax的异步问题","slug":"ajax的异步问题","link":"#ajax的异步问题","children":[]}]}],"relativePath":"start-docs/E-md/ajax.md","filePath":"start-docs/E-md/ajax.md"}');
const _sfc_main = { name: "start-docs/E-md/ajax.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="ajax" tabindex="-1">AJAX <a class="header-anchor" href="#ajax" aria-label="Permalink to &quot;AJAX&quot;">​</a></h1><h2 id="什么是ajax" tabindex="-1">什么是Ajax？ <a class="header-anchor" href="#什么是ajax" aria-label="Permalink to &quot;什么是Ajax？&quot;">​</a></h2><p>是指一种创建交互式网页应用的网页开发技术。</p><ul><li>AJAX：Asynchronous Javascript And XML（异步JavaScript和XML）</li><li>交互：这里的交互指客户端和服务器的数据是可以相互传递和使用的。</li><li>XML：一种类似于HTML的标记语言，可以将数据结构化，XML已经被JSON淘汰了。</li><li>异步：异步指程序可以同时执行，同步指程序需要按照顺序执行。</li></ul><p>特点: 在不提交整个页面的情况下,实现页面的局部刷新;</p><h3 id="ajax产生的背景" tabindex="-1">AJAX产生的背景： <a class="header-anchor" href="#ajax产生的背景" aria-label="Permalink to &quot;AJAX产生的背景：&quot;">​</a></h3><p>以前做数据交互的时候，大家通常选择使用表单的方式提交数据，表单提交这种方式，默认的时候会由当前页面跳转到action页面，所以用户体验及其糟糕，所以需要想办法让当前页面，不跳转的同时把数据传递过去，把服务器响应的内容拿回来。</p><h3 id="ajax解决的问题" tabindex="-1">AJAX解决的问题： <a class="header-anchor" href="#ajax解决的问题" aria-label="Permalink to &quot;AJAX解决的问题：&quot;">​</a></h3><p>指不刷新当前页面，把某些数据传递给服务器，把某些数据从服务器拿回客户端。</p><p><strong>注意：AJAX必须依赖服务执行，即使用http协议来运行。</strong></p><h2 id="创建ajax核心对象" tabindex="-1">创建Ajax核心对象 <a class="header-anchor" href="#创建ajax核心对象" aria-label="Permalink to &quot;创建Ajax核心对象&quot;">​</a></h2><div class="language-javascript codearea-link" id="41us6x4kwqr"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// W3C标准：</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> xhr </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">XMLHttpRequest</span><span style="color:#F8F8F2;">();</span></span></code></pre><button class="link">将此代码在线运行</button></div><div class="language-javascript codearea-link" id="89wksgg8lgj"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// IE标准： </span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> xhr </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">ActiveXObject</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;Msxml2.XMLHTTP&quot;</span><span style="color:#F8F8F2;">);	</span><span style="color:#88846F;">// msxml3.0</span></span>\n<span class="line"><span style="color:#88846F;">// or</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> xhr </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">ActiveXObject</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;Microsoft.XMLHTTP&quot;</span><span style="color:#F8F8F2;">);	</span><span style="color:#88846F;">// msxml2.6</span></span></code></pre><button class="link">将此代码在线运行</button></div><h2 id="建立连接" tabindex="-1">建立连接 <a class="header-anchor" href="#建立连接" aria-label="Permalink to &quot;建立连接&quot;">​</a></h2><div class="language-javascript codearea-link" id="ojkgn6aznxq"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// 语法：</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">open</span><span style="color:#F8F8F2;">(type, url, </span><span style="color:#AE81FF;">true</span><span style="color:#F8F8F2;">);</span></span></code></pre><button class="link">将此代码在线运行</button></div><p>open() 方法中:</p><ul><li>第1个参数指请求的发送方式，值为get或post。</li><li>第2个参数指请求的url路径。</li><li>第3个参数指请求是异步还是同步，如果写true表示异步（默认true），写false表示同步。</li></ul><h2 id="发起请求" tabindex="-1">发起请求 <a class="header-anchor" href="#发起请求" aria-label="Permalink to &quot;发起请求&quot;">​</a></h2><div class="language-javascript codearea-link" id="bhd8zigqh15"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// 语法：</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">send</span><span style="color:#F8F8F2;">();</span></span></code></pre><button class="link">将此代码在线运行</button></div><p>如果是get方式发送请求，send()命令中不用写任何参数</p><blockquote><p>传递的数据可以写在url中，服务器php文件用$_GET[&quot;参数名&quot;]接收。</p></blockquote><h2 id="接收响应" tabindex="-1">接收响应 <a class="header-anchor" href="#接收响应" aria-label="Permalink to &quot;接收响应&quot;">​</a></h2><div class="language-javascript codearea-link" id="ljxtoy17nkn"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#88846F;">// 异步时需要通过 onreadystatechange 监听</span></span>\n<span class="line"><span style="color:#88846F;">// 指如果xhr对象的预备好的状态发生了变化时，触发函数。</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">onreadystatechange</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(){</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;">(xhr.readyState </span><span style="color:#F92672;">==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">&amp;&amp;</span><span style="color:#F8F8F2;"> xhr.status </span><span style="color:#F92672;">==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">200</span><span style="color:#F8F8F2;">){</span></span>\n<span class="line"><span style="color:#F8F8F2;">		</span><span style="color:#A6E22E;">alert</span><span style="color:#F8F8F2;">(xhr.responseText);</span></span>\n<span class="line"><span style="color:#F8F8F2;">	}</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"><span style="color:#88846F;">// 请求状态4：响应已完成；您可以获取并使用服务器的响应了。</span></span>\n<span class="line"><span style="color:#88846F;">// HTTP状态码200：ok，页面正确打开，并得到完整的响应内容。</span></span></code></pre><button class="link">将此代码在线运行</button></div><ul><li>onreadystatechange指本次ajax请求的状态发生改变时所触发的事件</li><li>readyState 指请求状态</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">0：请求未初始化（还没有调用 open()）。</span></span>\n<span class="line"><span style="color:#F8F8F2;">1：请求已经建立，但是还没有发送（还没有调用 send()）。</span></span>\n<span class="line"><span style="color:#F8F8F2;">2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</span></span>\n<span class="line"><span style="color:#F8F8F2;">3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</span></span>\n<span class="line"><span style="color:#F8F8F2;">4：响应已完成；您可以获取并使用服务器的响应了。</span></span></code></pre></div><ul><li>status 指http状态（常用的http状态码，稍微了解下即可）</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">1**	信息，服务器收到请求，需要请求者继续执行操作</span></span>\n<span class="line"><span style="color:#F8F8F2;">2**	成功，操作被成功接收并处理</span></span>\n<span class="line"><span style="color:#F8F8F2;">3**	重定向，需要进一步的操作以完成请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">4**	客户端错误，请求包含语法错误或无法完成请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">5**	服务器错误，服务器在处理请求的过程中发生了错误</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">200：ok，页面正确打开，并得到完整的响应内容。</span></span>\n<span class="line"><span style="color:#F8F8F2;">301：被请求的资源已永久移动到新位置</span></span>\n<span class="line"><span style="color:#F8F8F2;">302：请求的资源临时从不同的 URI响应请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">304：缓存</span></span>\n<span class="line"><span style="color:#F8F8F2;">404：页面不存在。</span></span>\n<span class="line"><span style="color:#F8F8F2;">500：常指后端代码发生错误</span></span>\n<span class="line"><span style="color:#F8F8F2;">503：由于临时的服务器维护或者过载，服务器当前无法处理请求。</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">100	Continue	继续。客户端应继续其请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</span></span>\n<span class="line"><span style="color:#F8F8F2;">200	OK	请求成功。一般用于GET与POST请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">201	Created	已创建。成功请求并创建了新的资源</span></span>\n<span class="line"><span style="color:#F8F8F2;">202	Accepted	已接受。已经接受请求，但未处理完成</span></span>\n<span class="line"><span style="color:#F8F8F2;">203	Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</span></span>\n<span class="line"><span style="color:#F8F8F2;">204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</span></span>\n<span class="line"><span style="color:#F8F8F2;">205	Reset Content	重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</span></span>\n<span class="line"><span style="color:#F8F8F2;">206	Partial Content	部分内容。服务器成功处理了部分GET请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span></span>\n<span class="line"><span style="color:#F8F8F2;">301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span></span>\n<span class="line"><span style="color:#F8F8F2;">302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span></span>\n<span class="line"><span style="color:#F8F8F2;">303	See Other	查看其它地址。与301类似。使用GET和POST请求查看</span></span>\n<span class="line"><span style="color:#F8F8F2;">304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span></span>\n<span class="line"><span style="color:#F8F8F2;">305	Use Proxy	使用代理。所请求的资源必须通过代理访问</span></span>\n<span class="line"><span style="color:#F8F8F2;">306	Unused	已经被废弃的HTTP状态码</span></span>\n<span class="line"><span style="color:#F8F8F2;">307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向</span></span>\n<span class="line"><span style="color:#F8F8F2;">400	Bad Request	客户端请求的语法错误，服务器无法理解</span></span>\n<span class="line"><span style="color:#F8F8F2;">401	Unauthorized	请求要求用户的身份认证</span></span>\n<span class="line"><span style="color:#F8F8F2;">402	Payment Required	保留，将来使用</span></span>\n<span class="line"><span style="color:#F8F8F2;">403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</span></span>\n<span class="line"><span style="color:#F8F8F2;">405	Method Not Allowed	客户端请求中的方法被禁止</span></span>\n<span class="line"><span style="color:#F8F8F2;">406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span></span>\n<span class="line"><span style="color:#F8F8F2;">408	Request Time-out	服务器等待客户端发送的请求时间过长，超时</span></span>\n<span class="line"><span style="color:#F8F8F2;">409	Conflict	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</span></span>\n<span class="line"><span style="color:#F8F8F2;">410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span></span>\n<span class="line"><span style="color:#F8F8F2;">411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息</span></span>\n<span class="line"><span style="color:#F8F8F2;">412	Precondition Failed	客户端请求信息的先决条件错误</span></span>\n<span class="line"><span style="color:#F8F8F2;">413	Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</span></span>\n<span class="line"><span style="color:#F8F8F2;">414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理</span></span>\n<span class="line"><span style="color:#F8F8F2;">415	Unsupported Media Type	服务器无法处理请求附带的媒体格式</span></span>\n<span class="line"><span style="color:#F8F8F2;">416	Requested range not satisfiable	客户端请求的范围无效</span></span>\n<span class="line"><span style="color:#F8F8F2;">417	Expectation Failed	服务器无法满足Expect的请求头信息</span></span>\n<span class="line"><span style="color:#F8F8F2;">500	Internal Server Error	服务器内部错误，无法完成请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">501	Not Implemented	服务器不支持请求的功能，无法完成请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</span></span>\n<span class="line"><span style="color:#F8F8F2;">503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span></span>\n<span class="line"><span style="color:#F8F8F2;">504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求</span></span>\n<span class="line"><span style="color:#F8F8F2;">505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理</span></span></code></pre></div><p>responseText指接收到的响应结果</p><h2 id="get和post" tabindex="-1">GET和POST <a class="header-anchor" href="#get和post" aria-label="Permalink to &quot;GET和POST&quot;">​</a></h2><p>W3C建议我们使用get获取数据，使用post发送数据。</p><p>但实际上，无论是get还是post，都即可以发送数据，也可以接收数据。</p><p>区别：</p><ul><li>get是以url的方式传递数据；而post是以http请求中的body部分传递数据。所以有种说法说post更安全。</li><li>get传递数据时，直接在浏览器地址栏中可以看到；而post可以使用开发者工具中看到。</li><li>get传递的数据，中文会被编码或有可能出现乱码；而post不会。</li><li>get在IE下会走缓存；而post不会。</li></ul><p><strong>GET 和 POST 可传递的最大值是多少？</strong></p><p>网上流传的一种说法是，GET 256b，POST 2M，这种说法不太准确。</p><ul><li><p>GET 是通过 URL 传递的，HTTP协议没有对URL长度和参数个数进行限制。这个限制是特定的浏览器和服务器对URL进行了限制。IE为2083字节（2KB+35）；Firefox为65535字节；Safari为80000字节；Opera为190000字节；Chrome为8182字节；Apache能够接收url最大长度为8192字节；IIS为16384字节。</p></li><li><p>POST理论上没有长度的限制，HTTP协议没有对POST进行限制，起限制的是服务器的处理程序的处理能力。 Tomcat默认为2M；IIS默认为4M，也可以通过设置，让POST内容无限大，但要注意服务器和内存能力。</p></li></ul><div class="language-javascript codearea-link" id="dw7zirs8itp"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> xhr </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">XMLHttpRequest</span><span style="color:#F8F8F2;">();</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">open</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;post&quot;</span><span style="color:#F8F8F2;">, url, </span><span style="color:#AE81FF;">true</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#88846F;">// 如果是post方式发送请求，需要设置请求头才能正确把数据传递给后端页面。</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">setRequestHeader</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&#39;Content-Type&#39;</span><span style="color:#F8F8F2;">,</span><span style="color:#E6DB74;">&#39;application/x-www-form-urlencoded&#39;</span><span style="color:#F8F8F2;">);</span></span>\n<span class="line"><span style="color:#88846F;">// 客户端向服务器端发送数据，服务器php用$_POST[&quot;参数名&quot;]接收。</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">send</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&quot;数据名1=数据值&amp;数据名2=数据值&quot;</span><span style="color:#F8F8F2;">)</span></span>\n<span class="line"><span style="color:#88846F;">// 客户端接收服务器的响应内容</span></span>\n<span class="line"><span style="color:#F8F8F2;">xhr.</span><span style="color:#A6E22E;">onreadystatechange</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(){</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;">(xhr.readyState </span><span style="color:#F92672;">==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">4</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">&amp;&amp;</span><span style="color:#F8F8F2;"> xhr.status </span><span style="color:#F92672;">==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">200</span><span style="color:#F8F8F2;">){</span></span>\n<span class="line"><span style="color:#F8F8F2;">		</span><span style="color:#A6E22E;">alert</span><span style="color:#F8F8F2;">(xhr.responseText);</span></span>\n<span class="line"><span style="color:#F8F8F2;">	}</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div><h3 id="ajax的异步问题" tabindex="-1">Ajax的异步问题 <a class="header-anchor" href="#ajax的异步问题" aria-label="Permalink to &quot;Ajax的异步问题&quot;">​</a></h3><h4 id="同步和异步的概念" tabindex="-1">同步和异步的概念 <a class="header-anchor" href="#同步和异步的概念" aria-label="Permalink to &quot;同步和异步的概念&quot;">​</a></h4><p>同步: 按步骤 按顺序进行</p><p>异步: 同时执行,也叫并发;</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">举例说明: 假如</span></span>\n<span class="line"><span style="color:#F8F8F2;">吃饭(10分钟)   洗衣服(30分钟)   玩游戏(60分钟)</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">同步(按步骤 按顺序进行)</span></span>\n<span class="line"><span style="color:#F8F8F2;">先吃饭 -&gt;  洗衣服 -&gt; 玩游戏   (100)  // 单线程</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">异步(同时执行,也叫并发)</span></span>\n<span class="line"><span style="color:#F8F8F2;">吃饭 </span></span>\n<span class="line"><span style="color:#F8F8F2;">洗衣服    =&gt;   60   // 多线程</span></span>\n<span class="line"><span style="color:#F8F8F2;">玩游戏</span></span></code></pre></div><p>但是很尴尬 JS是单线程的.</p><p><strong>为什么JavaScript是单线程？</strong></p><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p><strong>Javascript 如何解决异步问题?</strong></p><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>JavaScript语言的设计者也意识到这个问题，于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行;</p><p>具体来说，异步执行的运行机制如下。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">（1）所有同步任务都在主线程(同步代码)上执行，形成一个执行栈（execution context stack）。</span></span>\n<span class="line"><span style="color:#F8F8F2;">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span></span>\n<span class="line"><span style="color:#F8F8F2;">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕(主线程代码执行完毕)，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈(主线程)，开始执行。</span></span>\n<span class="line"><span style="color:#F8F8F2;">（4）主线程不断重复上面的第三步</span></span></code></pre></div><h4 id="ajax封装" tabindex="-1">ajax封装 <a class="header-anchor" href="#ajax封装" aria-label="Permalink to &quot;ajax封装&quot;">​</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// 模拟jquery的$ajax的封装</span></span>\n<span class="line"><span style="color:#F8F8F2;">      $.ajax({</span></span>\n<span class="line"><span style="color:#F8F8F2;">        type, // get/post</span></span>\n<span class="line"><span style="color:#F8F8F2;">        url,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        data,  //  &quot;user=a123123&quot;  {user:&quot;a123123&quot;}</span></span>\n<span class="line"><span style="color:#F8F8F2;">        async,  //  true/false</span></span>\n<span class="line"><span style="color:#F8F8F2;">        dataType,  // text(默认)/json</span></span>\n<span class="line"><span style="color:#F8F8F2;">        success: function (res) { }  // 成功时的回调函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">    })</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// ajax_get_post</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // url, data, async = true, dataType = &quot;text&quot;, success</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function ajax(options) {  //此处只接受对象参数</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // let url = options.url;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // let data = options.data;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        let { type = &quot;get&quot;, url, data, async = true, dataType = &quot;text&quot;, success } = options;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        var req = new XMLHttpRequest();</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // req.open(&quot;get&quot;, &quot;../php/isExistUser.php?user=a123123&quot;, true);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 如果data 是字符串  就直接拼接  </span></span>\n<span class="line"><span style="color:#F8F8F2;">        //          是对象    遍历对象  转化为字符串</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        if (Object.prototype.toString.call(data) == &quot;[object Object]&quot;) {   //是对象    遍历对象  转化为字符串</span></span>\n<span class="line"><span style="color:#F8F8F2;">            var str = &quot;&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            for (var key in data) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                console.log(key, data[key]);</span></span>\n<span class="line"><span style="color:#F8F8F2;">                str += key + &quot;=&quot; + data[key] + &quot;&amp;&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            }</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(str);  //&quot;user=a123123&amp;pwd=123123&amp;&quot;   在讲多余的 &amp; 去掉</span></span>\n<span class="line"><span style="color:#F8F8F2;">            data = str.substring(0, str.length - 1);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        if (type == &quot;get&quot;) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            req.open(&quot;get&quot;, url + &quot;?&quot; + data, async)</span></span>\n<span class="line"><span style="color:#F8F8F2;">            req.send();</span></span>\n<span class="line"><span style="color:#F8F8F2;">        } else {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            req.open(&quot;post&quot;, url, async);</span></span>\n<span class="line"><span style="color:#F8F8F2;">            req.setRequestHeader(&quot;content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">            req.send(data);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        req.onreadystatechange = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            if (req.readyState == 4 &amp;&amp; req.status == 200) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                // console.log(req.responseText);</span></span>\n<span class="line"><span style="color:#F8F8F2;">                var result = req.responseText;  // 请求的数据（普通文本/JSON类型的字符串）</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">                if (dataType.toLowerCase() == &quot;json&quot;) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                    result = JSON.parse(result); // JSON类型的字符串</span></span>\n<span class="line"><span style="color:#F8F8F2;">                }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">                // console.log(result);</span></span>\n<span class="line"><span style="color:#F8F8F2;">                if (success) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                    success(result);  //  result   函数success调用时的实际参数</span></span>\n<span class="line"><span style="color:#F8F8F2;">                }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">            }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span></code></pre></div>', 56)
  ]));
}
const ajax = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  ajax as default
};
