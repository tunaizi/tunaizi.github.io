import{_ as i,r as t,i as e,a}from"./chunks/framework.15d2e201.js";const p=JSON.parse('{"title":"从一个 url 到页面展示的全流程","description":"","frontmatter":{},"headers":[{"level":2,"title":"浏览器接收 URL 到 开启网络请求线程","slug":"浏览器接收-url-到-开启网络请求线程","link":"#浏览器接收-url-到-开启网络请求线程","children":[]},{"level":2,"title":"开启网络请求线程 到 发出一个完整的 HTTP 请求","slug":"开启网络请求线程-到-发出一个完整的-http-请求","link":"#开启网络请求线程-到-发出一个完整的-http-请求","children":[]},{"level":2,"title":"服务器接收到请求 到 对应后台服务接收到请求","slug":"服务器接收到请求-到-对应后台服务接收到请求","link":"#服务器接收到请求-到-对应后台服务接收到请求","children":[]},{"level":2,"title":"浏览器接收 http 响应数据包后的解析","slug":"浏览器接收-http-响应数据包后的解析","link":"#浏览器接收-http-响应数据包后的解析","children":[]},{"level":2,"title":"HTML 解析构建","slug":"html-解析构建","link":"#html-解析构建","children":[]},{"level":2,"title":"CSS 解析和 JS 解析执行及绘制","slug":"css-解析和-js-解析执行及绘制","link":"#css-解析和-js-解析执行及绘制","children":[]},{"level":2,"title":"JS 引擎解析过程","slug":"js-引擎解析过程","link":"#js-引擎解析过程","children":[]},{"level":2,"title":"css 的可视化格式模型","slug":"css-的可视化格式模型","link":"#css-的可视化格式模型","children":[]},{"level":2,"title":"其他","slug":"其他","link":"#其他","children":[]}],"relativePath":"start-docs/all-docs/B-专题/从URL到显示网页的全过程.md","filePath":"start-docs/all-docs/B-专题/从URL到显示网页的全过程.md"}'),s={name:"start-docs/all-docs/B-专题/从URL到显示网页的全过程.md"};function r(o,l,n,h,u,c){return t(),e("div",null,l[0]||(l[0]=[a(`<h1 id="从一个-url-到页面展示的全流程" tabindex="-1">从一个 url 到页面展示的全流程 <a class="header-anchor" href="#从一个-url-到页面展示的全流程" aria-label="Permalink to &quot;从一个 url 到页面展示的全流程&quot;">​</a></h1><h2 id="浏览器接收-url-到-开启网络请求线程" tabindex="-1">浏览器接收 URL 到 开启网络请求线程 <a class="header-anchor" href="#浏览器接收-url-到-开启网络请求线程" aria-label="Permalink to &quot;浏览器接收 URL 到 开启网络请求线程&quot;">​</a></h2><ul><li>浏览器是多进程的，有一个主控进程，以及每一个 tab 页面会开启一个进程（某些情况下多 tab 会合并进程，比如打开多个空白页）</li><li>每个 tab 页面可以看做是一个浏览器的渲染进程（内核进程），这个进程是多线程的</li><li>一个进程分为 5 大类线程 <ol><li>GUI 渲染线程</li></ol><ul><li>负责浏览器渲染，如 html、css 解析，构建 dom 树和绘制树，布局和绘制等。</li><li>GUI 线程与 JS 互斥，当 JS 引擎执行时，GUI 线程就会被挂起，GUI 的更新会保存在一个队列中等待 JS 引擎空闲时立即执行。</li></ul><ol start="2"><li>JS 引擎线程</li></ol><ul><li>也称 js 内核，负责解析 JS 脚本并运行。</li></ul><ol start="3"><li>事件触发线程</li></ol><ul><li>负责控制事件循环。当 js 引擎遇到异步任务（settimeout、promise、ajax 等）时，就将这些任务添加到事件线程中，当对应的任务符合触发条件时，该线程会把事件添加到待处理的任务队列（Event Quene）的队尾，等待 JS 引擎处理。</li></ul><ol start="4"><li>定时器线程</li></ol><ul><li>负责 setTimeout 和 setInterval 的线程。通过单独的线程来进行计时并触发才不会影响计时的准确，因为 js 引擎是单线程，如果处于阻塞状态就会影响计时的准确。</li></ul><ol start="5"><li>异步请求线程</li></ol><ul><li>负责 XMLHttpRequest 请求的线程。当请求状态变更，就会将回调函数放入事件队列中等待 JS 引擎执行。</li><li>HTML5 新增 web worker 线程 <ul><li>由 JS 引擎线程向浏览器发起申请一个独立线程，由主线程完全控制，但是不能操作 dom。两个线程不会互相阻塞，只能通过 postMessage 来通信。通信的数据经过了序列化，传递的是值而不是引用，故而数据更改不会相互影响。</li></ul></li></ul></li><li>输入 URL 后，浏览器会解析，开启网络请求线程</li></ul><h2 id="开启网络请求线程-到-发出一个完整的-http-请求" tabindex="-1">开启网络请求线程 到 发出一个完整的 HTTP 请求 <a class="header-anchor" href="#开启网络请求线程-到-发出一个完整的-http-请求" aria-label="Permalink to &quot;开启网络请求线程 到 发出一个完整的 HTTP 请求&quot;">​</a></h2><ul><li>地址解析： 判断是合法的 URL 还是待搜索的关键词，并且根据输入的内容进行自动填充、字符编码等操作</li><li>浏览器使用 HSTS（HTTP Strict Transport Security）强制客户端使用 HTTPS 访问页面</li><li>浏览器的安全监测、访问限制</li><li>检查请求缓存，查看浏览器是否有缓存</li><li>DNS 查询 <ul><li>浏览器缓存 -&gt; 操作系统缓存（hosts 文件） -&gt; 路由器缓存 -&gt; DNS 服务器缓存 -&gt; 根域名服务器缓存</li><li>dns-prefetch 优化,在 html 标签中加入<link rel="dns-prefetch" href="//domain.com"> 进行域名预解析</li><li>通过 DNS 解析得到域名对应的 IP 地址</li></ul></li><li>应用层：发送 HTTP 请求，携带 http 报文（请求报头和主体）</li><li>传输层：TCP 传输报文。向服务端发起 TCP 连接，建立连接前会进行 TCP 三次握手。 <ul><li>三次握手：<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">客户端：hello，你是server么？</span></span>
<span class="line"><span style="color:#e1e4e8;">  服务端：hello，我是server，你是client么</span></span>
<span class="line"><span style="color:#e1e4e8;">  客户端：yes，我是client</span></span></code></pre></div></li><li>get 和 post 虽然本质都是 tcp/ip，但两者除了在 http 层面外，在 tcp/ip 层面也有区别。get 会产生一个 tcp 数据包，post 两个</li></ul></li><li>网络层： IP 协议查询 Mac 地址</li><li>数据链路层：根据以太网协议将数据分为以“帧”为单位的数据包</li><li>物理传输层： 利用物理介质传输比特流</li></ul><h2 id="服务器接收到请求-到-对应后台服务接收到请求" tabindex="-1">服务器接收到请求 到 对应后台服务接收到请求 <a class="header-anchor" href="#服务器接收到请求-到-对应后台服务接收到请求" aria-label="Permalink to &quot;服务器接收到请求 到 对应后台服务接收到请求&quot;">​</a></h2><ul><li>数据传输到服务器（常见的 apache 和 nginx），会监听得到请求，开启一个子进程来处理。这里服务器可能是集群，会经历负载均衡。</li><li>请求到分配后的容器服务器，处理请求，接收 TCP 报文后，会对连接进行处理，对 http 协议进行解析，并进行安全验证</li><li>查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js 文件等，会直接返回这个文件</li><li>如果是服务器的接口服务，则进入 java 应用服务，开始处理,mvc,最终返回响应</li></ul><h2 id="浏览器接收-http-响应数据包后的解析" tabindex="-1">浏览器接收 http 响应数据包后的解析 <a class="header-anchor" href="#浏览器接收-http-响应数据包后的解析" aria-label="Permalink to &quot;浏览器接收 http 响应数据包后的解析&quot;">​</a></h2><ul><li>浏览器接收到来自服务器的响应资源后，会对资源进行分析。</li><li>查看 response header,根据不同的状态码做相应的反馈。如果响应资源做了 gzip 压缩，还需要进行解压。</li><li>查看响应资源的缓存返回机制做响应的处理。</li><li>根据响应资源里的 MIME(媒体类型)解析响应的内容，这里以 HTML 返回为例</li></ul><h2 id="html-解析构建" tabindex="-1">HTML 解析构建 <a class="header-anchor" href="#html-解析构建" aria-label="Permalink to &quot;HTML 解析构建&quot;">​</a></h2><ul><li>浏览器的解析是从上往下逐行解析。</li><li>解码：浏览器接收到二进制流，浏览器根据文件执行编码方式（utf-8）进行 encoding 解码转成字符串流。</li><li>符号化（tokenization）: 将字符串流解析成符号 token，html 符号包括开始标签、结束标签、属性名和属性值。它是通过一个状态机来识别符号的状态。</li><li>构建 DOM 树: 通过符号化得到的标记 token,最终生成 DOM 树。</li><li>当整个解析的过程完成以后，浏览器会通过 DOMContentLoaded 事件来通知 DOM 解析完成。</li></ul><h2 id="css-解析和-js-解析执行及绘制" tabindex="-1">CSS 解析和 JS 解析执行及绘制 <a class="header-anchor" href="#css-解析和-js-解析执行及绘制" aria-label="Permalink to &quot;CSS 解析和 JS 解析执行及绘制&quot;">​</a></h2><ul><li>CSS 的加载不会影响 DOM 树的解析，会阻塞 render 树的渲染。css 的加载会阻塞 JS 的语句执行。</li><li>JS 的加载和执行会阻塞 DOM 树的解析和渲染。因为 JS 可能会动态操作 DOM。可以通过异步的方式加载脚本。 defer 是延迟执行，而 async 是异步执行。</li><li>原则： CSS 资源放在 JS 资源前，一般放在 head，JS 资源放在 HTML 最底部，也就是 <code>&lt;body&gt;&lt;/body&gt;</code>之前</li><li>在解析 DOM 的同时，当遇到外部资源时会放到下载队列，会由单独的异步线程下载资源。</li><li>CSS 资源加载完成，会和 DOM 解析同步解析成 CSSOM 树。</li><li>构建渲染树：render Tree <ul><li>当 DOM 树和 CSSOM 树都建立完后，开始进行合并，也就是渲染树。</li><li>渲染树会忽略不需要渲染的节点，例如：display:none 的节点。所以渲染树和 DOM 树不是严格的一一对应。</li></ul></li><li>布局 layout 和绘制 paint：确定渲染树所有节点的几何属性，通过元素的盒模型生成相应的位图。</li><li>合并绘制：将所有的位图合并成一个图片展示在显示屏上。</li><li>重排（回流 reflow）当浏览器发现某个部门发现变化影响布局时，需要从 html 标签开始递归往下，重新计算位置和大小。例如：滑动鼠标、resize 窗口都会发生变化。重排一定会引起重绘。</li><li>重绘：当改变了某个元素的背景色、文字颜色等不影响位置和大小的变化，就会触发重绘。每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。</li><li>回流的成本比重绘高很多，所以我们尽量避免回流。</li><li>display:none 会触发回流，而 visiblity:hidden 只会触发重绘。</li></ul><h2 id="js-引擎解析过程" tabindex="-1">JS 引擎解析过程 <a class="header-anchor" href="#js-引擎解析过程" aria-label="Permalink to &quot;JS 引擎解析过程&quot;">​</a></h2><ul><li>一阶段： 语法解析 -&gt; 词法单元 -&gt; 抽象语法树（AST） -&gt; 机器指令</li><li>二阶段： 预处理 -&gt; 运行环境 -&gt; 函数调用栈 -&gt; 执行上下文</li><li>三阶段： 执行 -&gt; 事件循环 <ul><li>-&gt; 宏任务</li><li>-&gt; 微任务</li></ul></li></ul><h2 id="css-的可视化格式模型" tabindex="-1">css 的可视化格式模型 <a class="header-anchor" href="#css-的可视化格式模型" aria-label="Permalink to &quot;css 的可视化格式模型&quot;">​</a></h2><ul><li>css 中规定每一个元素都有自己的盒子模型</li><li>可视化格式模型则是规定如何将这些盒子布局及相互作用</li><li><strong>可视化格式模型：浏览器按照一定规则对文档树进行可视化处理</strong></li><li>包含：包含块，控制框，BFC，IFC，定位体系，浮动等</li></ul><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><ul><li>扩展 <ul><li>浏览器是多进程的，浏览器内核是多线程的，JS 引擎是单线程的</li><li>进程是 CPU 资源分配的最小单元，线程是 CPU 调度的最小单元</li><li>DomContentLoad 和 load <ul><li>DomContentLoad 触发，仅当 dom 加载完成，不包括 css 和图片或者异步的 js 加载完成</li><li>load 事件触发，页面上所有的 dom、css、脚本和图片都已经加载完了。</li></ul></li><li>重排(因为是流式布局，也称回流)、重绘 [<a href="https://blog.csdn.net/lixiaosenlin/article/details/108262343" target="_blank" rel="noreferrer">https://blog.csdn.net/lixiaosenlin/article/details/108262343</a>]</li><li>DOM 元素的几何属性发生变化，如尺寸（width），位置（psoition）等</li><li>DOM 树结构发生变化</li><li>调整浏览器窗口大小</li><li>改变元素的一些样式，如 display，float 等等</li><li>获取下列属性时：offsetTop/offsetLeft/offsetWidth/offsetHeight/scrollTop/scrollLeft/scrollWidth/scrollHeight/clientTop/clientLeft/clientHeight/getComputedStyle()/currentStyle()</li></ul></li><li>参考 <ul><li>[<a href="https://zhuanlan.zhihu.com/p/34453198" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/34453198</a>]</li><li>[<a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/80551769</a>]</li><li>[<a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000012925872</a>]</li></ul></li></ul>`,19)]))}const g=i(s,[["render",r]]);export{p as __pageData,g as default};
