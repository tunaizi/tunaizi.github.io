import { _ as _export_sfc, r as r3, i as it, v as ig } from "./chunks/framework.ccd34752.js";
const __pageData = JSON.parse('{"title":"管理作用域","description":"","frontmatter":{},"headers":[{"level":2,"title":"函数","slug":"函数","link":"#函数","children":[]},{"level":2,"title":"对象","slug":"对象","link":"#对象","children":[]},{"level":2,"title":"函数执行过程","slug":"函数执行过程","link":"#函数执行过程","children":[]},{"level":2,"title":"闭包、作用域和内存","slug":"闭包、作用域和内存","link":"#闭包、作用域和内存","children":[]},{"level":2,"title":"对象成员","slug":"对象成员","link":"#对象成员","children":[]},{"level":2,"title":"null undefined 等特殊性质","slug":"null-undefined-等特殊性质","link":"#null-undefined-等特殊性质","children":[]}],"relativePath":"start-docs/B-JS/JS作用域.md","filePath":"start-docs/B-JS/JS作用域.md"}');
const _sfc_main = { name: "start-docs/B-JS/JS作用域.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="管理作用域" tabindex="-1">管理作用域 <a class="header-anchor" href="#管理作用域" aria-label="Permalink to &quot;管理作用域&quot;">​</a></h1><ul><li>数据存储共有 4 中方式： 字面量、变量、数组项、对象成员。</li><li>访问字面量和局部变量速度最快，访问数组元素和对象成员较慢。</li><li>全局变量总出在作用域链的最末端，访问速度总是比局部变量慢。</li></ul><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><ul><li>每一个 js 函数都表示为一个对象，更确切的说，是 Function 对象的实例。</li></ul><h2 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h2><ul><li>对象拥有可以访问的属性和只能 js 引擎存取的内部属性。</li><li>[[scope]]：就是内部属性。包含了一个函数被创建的作用域中对象的集合。</li></ul><h2 id="函数执行过程" tabindex="-1">函数执行过程 <a class="header-anchor" href="#函数执行过程" aria-label="Permalink to &quot;函数执行过程&quot;">​</a></h2><ul><li>创建一个执行环境的内部对象</li><li>初始化作用域链，将当前运行函数的[[scope]]的属性复制到执行环境的作用域链中，并推入到作用域链最前端。 这个新对象就是活动对象。</li><li>会经历标识符解析过程，该过程就是搜索执行环境的作用域链。会一直向下查找，直到找不到就会认为未定义。</li><li>这个过程会影响性能。固然尽可能使用局部变量。</li><li>改变作用域链有两种方式，with 及 try-catch,catch 会将异常对象推入一个变量对象并放在作用域最前端，函数的局部变量会放在第二个作用域对象中。当执行 catch 完成后，就会返回之前的状态。</li><li>动态作用域链（with,try-catch,eval)。只存在代码执行过程中，无法通过静态分析检测。</li></ul><h2 id="闭包、作用域和内存" tabindex="-1">闭包、作用域和内存 <a class="header-anchor" href="#闭包、作用域和内存" aria-label="Permalink to &quot;闭包、作用域和内存&quot;">​</a></h2><ul><li>闭包：本质就是一个绑定了执行环境的函数 <ul><li>允许函数访问局部作用域之外的数据。</li><li>闭包创建时[[scope]]属性对象和执行环境作用域链的对象引用是相同的。在函数执行完成后，活动对象本来会销毁，但是由于与闭包内的引用还存在闭包[[scope]]中，故而不会销毁。闭包会增加内存开销。</li></ul></li></ul><h2 id="对象成员" tabindex="-1">对象成员 <a class="header-anchor" href="#对象成员" aria-label="Permalink to &quot;对象成员&quot;">​</a></h2><ul><li>原型 <ul><li>js 中的对象是基础原型的。它定义并实现了一个新创建的对象必须包含的成员列表。</li><li>所有实例对象都共享原型对象的成员。</li><li>对象通过一个内部属性绑定到它的原型（<strong>proto</strong>）。一旦创建了一个内置对象（Object 和 Array）的实例，就自动拥有一个 Object 实例作为原型。</li><li>实例对象的(<strong>proto</strong>) -&gt; Object.prototype</li><li>一个实例对象可以有两种成员类型：实例成员（也成为 own 成员）和原型成员。</li><li>hasOwnProperty()就是用来判断对象是否包含特定的实例成员。</li><li>key in object 可以判断所有成员 eg: &#39;toString&#39; in book //true <strong>in 操作既会搜索实例成员也会搜索原型成员</strong></li></ul></li><li>原型链 <ul><li>所有对象都是对象（Object）的实例。并继承了所有方法。eg： Function instanceof Object //true。除了 null 和 undefined 不是 Object 的实例</li><li>经典例子：<div class="language-js codearea-link" id="fx94sngwz7"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">Book</span><span style="color:#F8F8F2;">(){} </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> book </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">Book</span><span style="color:#F8F8F2;">()</span></span>\n<span class="line"><span style="color:#F8F8F2;">  book.__proto__ </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">Book</span><span style="color:#F8F8F2;">.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">Book</span><span style="color:#F8F8F2;">.prototype.__proto__ </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">Object</span><span style="color:#F8F8F2;">.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">Object</span><span style="color:#F8F8F2;">.prototype.__proto__ </span><span style="color:#F92672;">====</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span></span></code></pre><button class="link">将此代码在线运行</button></div></li></ul></li></ul><h2 id="null-undefined-等特殊性质" tabindex="-1">null undefined 等特殊性质 <a class="header-anchor" href="#null-undefined-等特殊性质" aria-label="Permalink to &quot;null undefined 等特殊性质&quot;">​</a></h2><ul><li><p>typeof null //object</p></li><li><p>typeof undefined // undefined</p></li><li><p>typeof NaN // number</p></li><li><p>typeof Function // &quot;function&quot;</p></li><li><p>typeof Array // &quot;function&quot;</p></li><li><p>typeof Object // &quot;function&quot;</p></li><li><p>typeof Number // &quot;function&quot;</p></li><li><p>typeof String // &quot;function&quot;</p></li><li><p>null instanceof Object //false</p></li><li><p>NaN instanceof Object //false</p></li><li><p>undefined instanceof Object //false</p></li><li><p>Function instanceof Object //true</p></li><li><p>Array instanceof Object //true</p></li><li><p>Array instanceof Function //true</p></li><li><p>String instanceof Function //true</p></li><li><p>String instanceof Object //true</p></li></ul>', 14)
  ]));
}
const JS___ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  JS___ as default
};
