import{_ as e,r as l,i as a,a as n}from"./chunks/framework.e3a88a6f.js";const m=JSON.parse('{"title":"模块化","description":"","frontmatter":{},"headers":[{"level":2,"title":"IIFE 立即执行函数","slug":"iife-立即执行函数","link":"#iife-立即执行函数","children":[]},{"level":2,"title":"CommonJs","slug":"commonjs","link":"#commonjs","children":[]},{"level":2,"title":"AMD 异步模块加载","slug":"amd-异步模块加载","link":"#amd-异步模块加载","children":[]},{"level":2,"title":"CMD","slug":"cmd","link":"#cmd","children":[{"level":3,"title":"CMD和AMD区别","slug":"cmd和amd区别","link":"#cmd和amd区别","children":[]}]},{"level":2,"title":"UMD","slug":"umd","link":"#umd","children":[]},{"level":2,"title":"ES Modules","slug":"es-modules","link":"#es-modules","children":[{"level":3,"title":"参考","slug":"参考","link":"#参考","children":[]}]}],"relativePath":"start-docs/studyhard/1专题/模块化及打包模式.md","filePath":"start-docs/studyhard/1专题/模块化及打包模式.md"}'),i={name:"start-docs/studyhard/1专题/模块化及打包模式.md"};function o(t,s,p,c,r,d){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h1><ul><li>模块化主要用于抽离公共代码，隔离作用域，避免变量冲突等。</li><li>可维护性，减少全局变量污染，可复用性，方便管理依赖关系。</li></ul><h2 id="iife-立即执行函数" tabindex="-1">IIFE 立即执行函数 <a class="header-anchor" href="#iife-立即执行函数" aria-label="Permalink to &quot;IIFE 立即执行函数&quot;">​</a></h2><ul><li>立即执行函数，可以通过匿名闭包的形式实现模块化</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">var aa = &#39;123&#39;;</span></span>
<span class="line"><span style="color:#e1e4e8;">(function(w){</span></span>
<span class="line"><span style="color:#e1e4e8;">  var bb = &#39;456&#39;;</span></span>
<span class="line"><span style="color:#e1e4e8;">  console.log(aa, bb)</span></span>
<span class="line"><span style="color:#e1e4e8;">  w.bb = bb</span></span>
<span class="line"><span style="color:#e1e4e8;">})(window);</span></span>
<span class="line"><span style="color:#e1e4e8;">console.log(aa, bb);</span></span></code></pre></div><h2 id="commonjs" tabindex="-1">CommonJs <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;CommonJs&quot;">​</a></h2><ul><li>实现状况 <ul><li>服务端： node</li><li>浏览器： webpack和browserify 打包后运行</li></ul></li><li>特点 <ul><li>模块加载<strong>同步</strong>，即资源加载完再执行</li><li>每个文件都可以是一个模块</li><li>服务端：模块加载是运行时同步加载</li><li>浏览器：模块加载是提前编译打包处理</li><li>通过require来同步加载所依赖的模块，通过exports来导出对外暴露的接口。</li><li>通过require引用文件时，会执行文件，将其执行的结果通过浅克隆写入全局内存。</li></ul></li><li>实现<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">//定义模块 (lib/math.js)</span></span>
<span class="line"><span style="color:#e1e4e8;">  //规定一个文件就是一个模块</span></span>
<span class="line"><span style="color:#e1e4e8;">  const name = &#39;july&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">  module.exports.author = name</span></span>
<span class="line"><span style="color:#e1e4e8;">  module.exports.add = (a,b) =&gt; a + b</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">//加载模块</span></span>
<span class="line"><span style="color:#e1e4e8;">  const mathLib = require(&#39;./lib/math&#39;)</span></span>
<span class="line"><span style="color:#e1e4e8;">  console.log(mathLib.author, mathLib.add)</span></span></code></pre></div></li><li>浏览器中不支持commonJS规范，只能使用webpack或者browserify将commonjs转换。</li></ul><h2 id="amd-异步模块加载" tabindex="-1">AMD 异步模块加载 <a class="header-anchor" href="#amd-异步模块加载" aria-label="Permalink to &quot;AMD 异步模块加载&quot;">​</a></h2><ul><li>使用requireJS来编写模块化 <ul><li>依赖必须提前声明，显示列出依赖关系。</li><li>模块加载<strong>异步</strong>，指定回调函数</li><li>推崇<strong>依赖前置，提前执行</strong></li></ul></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">//指定引用路径</span></span>
<span class="line"><span style="color:#e1e4e8;">  requier.config() </span></span>
<span class="line"><span style="color:#e1e4e8;">  //定义模块（定义时也可以依赖其他模块）</span></span>
<span class="line"><span style="color:#e1e4e8;">  define(&#39;./a.js&#39;, function(code) {</span></span>
<span class="line"><span style="color:#e1e4e8;">    // code就是index.js的内容</span></span>
<span class="line"><span style="color:#e1e4e8;">    test</span></span>
<span class="line"><span style="color:#e1e4e8;">    console.log(&#39;I am A module&#39;)</span></span>
<span class="line"><span style="color:#e1e4e8;">  })</span></span>
<span class="line"><span style="color:#e1e4e8;">  // 引入</span></span>
<span class="line"><span style="color:#e1e4e8;">  require([&#39;module1&#39;, &#39;module2&#39;], function(m1, m2) {</span></span>
<span class="line"><span style="color:#e1e4e8;">    // m1,m2</span></span>
<span class="line"><span style="color:#e1e4e8;">  })</span></span></code></pre></div><ul><li>在浏览器中使用时，需要引入require.js的支持。</li></ul><h2 id="cmd" tabindex="-1">CMD <a class="header-anchor" href="#cmd" aria-label="Permalink to &quot;CMD&quot;">​</a></h2><ul><li>使用seaJs来编写模块化</li><li>与AMD类似，推崇<strong>依赖就近，延迟执行</strong></li><li>模块按需加载</li><li>支持动态引入依赖文件</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">// 定义模块(math.js)</span></span>
<span class="line"><span style="color:#e1e4e8;">  define(function(require, exports, module){</span></span>
<span class="line"><span style="color:#e1e4e8;">    var $ = require(&#39;jQuery)</span></span>
<span class="line"><span style="color:#e1e4e8;">    var add = function(a, b) { return a + b}</span></span>
<span class="line"><span style="color:#e1e4e8;">    exports.add = add;</span></span>
<span class="line"><span style="color:#e1e4e8;">  })</span></span>
<span class="line"><span style="color:#e1e4e8;">  //使用</span></span>
<span class="line"><span style="color:#e1e4e8;">  seajs.use([&#39;math.js&#39;], function(math) {</span></span>
<span class="line"><span style="color:#e1e4e8;">    math.add(1+2)</span></span>
<span class="line"><span style="color:#e1e4e8;">  })</span></span></code></pre></div><h3 id="cmd和amd区别" tabindex="-1">CMD和AMD区别 <a class="header-anchor" href="#cmd和amd区别" aria-label="Permalink to &quot;CMD和AMD区别&quot;">​</a></h3><ul><li>对依赖模块的执行时机不同，注意：不是加载的时机，模块加载的时机是一样的！！！</li><li>CMD如何控制哪个模块执行时机？ <ul><li>执行模块，都是执行modules[id].callback();</li><li>AMD提前得到依赖的模块数组。</li><li>CMD中： <ul><li>先将传递进来的函数转成字符串，&#39;function (){var a = require(&quot;2.js&quot;)}&#39;</li><li>利用正则函数，取出字符串中的依赖2.js放入依赖数组中即可</li></ul></li></ul></li></ul><h2 id="umd" tabindex="-1">UMD <a class="header-anchor" href="#umd" aria-label="Permalink to &quot;UMD&quot;">​</a></h2><ul><li>兼容AMD（浏览器）和commonJs（服务端nodejs），解决跨平台的问题。</li><li>核心思想： if-else。 <ul><li>先判断是否支持nodejs的模块（exports）的存在，存在则使用nodejs的模式。</li><li>再判断是否支持AMD(define的存在)，存在则使用AMD方式加载模块</li></ul></li><li>常用用法<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">(function(window, factory) {</span></span>
<span class="line"><span style="color:#e1e4e8;">    if(typeof exports === &#39;object&#39;) {</span></span>
<span class="line"><span style="color:#e1e4e8;">      module.exports = factory();</span></span>
<span class="line"><span style="color:#e1e4e8;">    } else if(typeof define === &#39;function&#39; &amp;&amp; define.amd) {</span></span>
<span class="line"><span style="color:#e1e4e8;">      define(factory)</span></span>
<span class="line"><span style="color:#e1e4e8;">    } else {</span></span>
<span class="line"><span style="color:#e1e4e8;">      window.eventUtil = factory()</span></span>
<span class="line"><span style="color:#e1e4e8;">    }</span></span>
<span class="line"><span style="color:#e1e4e8;">  })(this, function(){</span></span>
<span class="line"><span style="color:#e1e4e8;">    //module</span></span>
<span class="line"><span style="color:#e1e4e8;">  })</span></span></code></pre></div></li></ul><h2 id="es-modules" tabindex="-1">ES Modules <a class="header-anchor" href="#es-modules" aria-label="Permalink to &quot;ES Modules&quot;">​</a></h2><ul><li>es6引入的模块化，支持import引入依赖 通过export到处依赖</li><li>依赖模块是不会先去预加载整个脚本，而是生成一个引用，并且静态解析依赖，等到代码执行时才取出实际的模块。</li><li>与commonjs差异 <ul><li>commonjs模块输出的是一个值的拷贝，es6模块输出的是值的引用</li><li>commonjs模块是运行时加载，es6模块是编译时输出接口</li></ul></li><li>特点： <ul><li>每一个模块多次，js只执行一次，如果下次再去加载同目录下同文件，直接从内存中读取。一个模块就是一个单例，或者是一个对象。</li><li>代码在模块作用域之中运行，而不是在全局作用域中。模块内部的顶层变量，外部不可见。不会污染全局。</li><li>模块脚本自动采用严格模式</li><li>模块之中可以使用import命令加载其他模块，也可以export输出对外接口</li><li>模块之中，顶层的this关键字返回undefined,而不是指向window。也就是说模块顶层使用this关键字是无意义的。</li></ul></li><li>html中使用模块<div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark"><code><span class="line"><span style="color:#e1e4e8;">&lt;script type=&quot;module&quot; src=&quot;./module.js&quot;&gt;&lt;/script&gt;</span></span></code></pre></div></li></ul><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><ul><li>[<a href="https://mp.weixin.qq.com/s/AuBFvgHPVAiT77Y03CsofQ" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/AuBFvgHPVAiT77Y03CsofQ</a>]</li><li>[<a href="https://github.com/Nealyang/PersonalBlog/issues/61" target="_blank" rel="noreferrer">https://github.com/Nealyang/PersonalBlog/issues/61</a>]</li><li>[<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28" target="_blank" rel="noreferrer">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28</a>]</li><li>模块化思维导图[<a href="https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map" target="_blank" rel="noreferrer">https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map</a>]</li></ul>`,22)]))}const h=e(i,[["render",o]]);export{m as __pageData,h as default};
