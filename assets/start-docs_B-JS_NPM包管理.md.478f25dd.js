import { _ as _export_sfc, b as r3, c as it, S as ig } from "./chunks/framework.6235ba6c.js";
const __pageData = JSON.parse('{"title":"NPM包管理机制","description":"","frontmatter":{},"headers":[{"level":2,"title":"npm install后发生了什么","slug":"npm-install后发生了什么","link":"#npm-install后发生了什么","children":[{"level":3,"title":"参考","slug":"参考","link":"#参考","children":[]}]}],"relativePath":"start-docs/B-JS/NPM包管理.md","filePath":"start-docs/B-JS/NPM包管理.md"}');
const _sfc_main = { name: "start-docs/B-JS/NPM包管理.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="npm包管理机制" tabindex="-1">NPM包管理机制 <a class="header-anchor" href="#npm包管理机制" aria-label="Permalink to &quot;NPM包管理机制&quot;">​</a></h1><ul><li>早期npm版本中，npm处理依赖方式简单粗暴，以递归的形式安装所有依赖。</li><li>npm 3.x版本之后更新为扁平结构。优先安装在node_modules根目录。当新的依赖版本不符合已有包的版本规则，则放在当前包下的node_modules下。</li><li>npm 5.x版本增加package-lock.json。用于锁定依赖结构。</li><li>版本的格式 major.minor.patch 主版本.次版本.修补版本号</li><li>版本匹配规则 <ul><li>锁定版本 1.1.2</li><li>可以大于或等于某个版本 &gt;=1.1.2</li><li>可以小于某个版本 &lt;1.1.2</li><li>指定范围 1.2.2-2.2.1 相当于 &gt;=1.2.2 &lt;2.2.1</li><li>大概匹配某个版本 ~1.1.2 <ul><li>~1.1.2指定修补版本，则必须大于修补版本 相当于是 &gt;=1.1.2 &lt;1.2.0</li><li>~1.1指定次版本，则次版本不变，修复版本任意 相当于是1.1.n (&gt;=1.1.0 &amp;&amp; &lt;1.2.0)</li><li>~1指定主版本，则主版本不变，后续任意 相当于1.n (&gt;=1.0.0&amp;&lt;2.0.0)</li></ul></li><li>兼容某个版本 <ul><li>版本号中最左边的非0数字的右侧可以是任意</li><li>如果缺少某个版本号，则这个版本号的位置可以是任意</li><li>^1.1.2 表示&gt;=1.1.2 &lt;2.0.0</li><li>^0.2.3 表示&gt;=0.2.3 &lt;0.3.0</li><li>^0.0 表示&gt;=0.0.0 &lt;0.1.0</li></ul></li><li>标识符1.2.x 表示修补版本可以任意</li></ul></li></ul><h2 id="npm-install后发生了什么" tabindex="-1">npm install后发生了什么 <a class="header-anchor" href="#npm-install后发生了什么" aria-label="Permalink to &quot;npm install后发生了什么&quot;">​</a></h2><ul><li>执行npm工程自身的preinstall,如果当前npm工程定义了preinstall钩子，则会被优先执行</li><li>确定首层依赖模块 <ul><li>也就是确定dependencies和devDependencies属性中的直接指定的模块</li><li>工程本身是整个依赖树的根节点，每个首层依赖模块都是根节点下面的一颗子树，npm会开启多进程从每个首层依赖模块开始逐步寻找更深层次的节点。</li></ul></li><li>获取模块（是一个递归的过程） <ul><li>获取模块信息，优先查找package-lock.json中指定的包地址，如果没有则从仓库中获取。如package.json中某个包是^1.1.2。则去仓库获取符合1.x.x的最新版本</li><li>获取模块实体。通过上一步的模块信息中的地址，检查本地是否有缓存，没有则从仓库下载</li><li>查找该版本依赖，有则回到第一步继续获取依赖的版本信息，没有则停止</li></ul></li></ul><h3 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h3><ul><li>[<a href="https://segmentfault.com/a/1190000041396029" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000041396029</a>]</li><li>[<a href="https://zhuanlan.zhihu.com/p/128625669" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/128625669</a>]</li><li>[<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22" target="_blank" rel="noreferrer">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22</a>]</li></ul>', 6)
  ]));
}
const NPM___ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  NPM___ as default
};
