import { _ as _export_sfc, b as r3, c as it, S as ig } from "./chunks/framework.9c9a3542.js";
const __pageData = JSON.parse('{"title":"面向过程和面向对象","description":"","frontmatter":{},"headers":[{"level":3,"title":"面向过程","slug":"面向过程","link":"#面向过程","children":[]},{"level":3,"title":"面向对象","slug":"面向对象","link":"#面向对象","children":[]},{"level":2,"title":"面向对象的封装","slug":"面向对象的封装","link":"#面向对象的封装","children":[]},{"level":2,"title":"原型和原型链","slug":"原型和原型链","link":"#原型和原型链","children":[]},{"level":2,"title":"ES6 构造函数(类)","slug":"es6-构造函数-类","link":"#es6-构造函数-类","children":[]},{"level":2,"title":"面向对象的继承","slug":"面向对象的继承","link":"#面向对象的继承","children":[{"level":3,"title":"构造函数继承","slug":"构造函数继承","link":"#构造函数继承","children":[]},{"level":3,"title":"原型继承","slug":"原型继承","link":"#原型继承","children":[]},{"level":3,"title":"组合继承","slug":"组合继承","link":"#组合继承","children":[]},{"level":3,"title":"ES6的继承","slug":"es6的继承","link":"#es6的继承","children":[]},{"level":3,"title":"面向对象之多态","slug":"面向对象之多态","link":"#面向对象之多态","children":[]}]}],"relativePath":"start-docs/E-md/面向对象.md","filePath":"start-docs/E-md/面向对象.md"}');
const _sfc_main = { name: "start-docs/E-md/面向对象.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="面向过程和面向对象" tabindex="-1">面向过程和面向对象 <a class="header-anchor" href="#面向过程和面向对象" aria-label="Permalink to &quot;面向过程和面向对象&quot;">​</a></h1><h3 id="面向过程" tabindex="-1">面向过程 <a class="header-anchor" href="#面向过程" aria-label="Permalink to &quot;面向过程&quot;">​</a></h3><p>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p><p>经典案例 :</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">(1) 购物车  (1. 获取元素 2. 加号事件 3.减号事件 4.全选/反选 5.单删和全删 6.合计)</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">  (2) 元素拖拽(1. 获取元素 2. 当鼠标按下，确定按下的位置 3.鼠标在文档移动时,盒子跟随移动 4.鼠标抬起，停止移动)</span></span></code></pre></div><h3 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h3><p>思想上提升 , 就是将你的需求抽象成一个对象,然后针对这个对象分析其特征(属性)与行为(方法)--这个对象就称之为类</p><p>也就是说 把构成问题的事务（事务：一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit) ），分解成各个对象，建立对象的目的是为了描述某个事物在整个解决问题的步骤中的行为</p><p>京东网站</p><p>​ 注册模块 , 登录模块,图片轮播,商品动态生成 , 商品搜索</p><p>​</p><p>举例说明</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">把大象放进冰箱中需要几步</span></span>\n<span class="line"><span style="color:#F8F8F2;">    (1)  面向过程 (分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        1.1  需要的事物  大象  冰箱</span></span>\n<span class="line"><span style="color:#F8F8F2;">        1.2  打开冰箱</span></span>\n<span class="line"><span style="color:#F8F8F2;">        1.3  把大象放进冰箱中</span></span>\n<span class="line"><span style="color:#F8F8F2;">        1.4  关上冰箱</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    (2)  面向对象  (把大象放进冰箱)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        冰箱的对象 = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            target:&quot;大象&quot;, //  猪肉，苹果，脆脆冰</span></span>\n<span class="line"><span style="color:#F8F8F2;">            打开:方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">            放东西:方法  // 放target</span></span>\n<span class="line"><span style="color:#F8F8F2;">            关闭:方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span></code></pre></div><h2 id="面向对象的封装" tabindex="-1">面向对象的封装 <a class="header-anchor" href="#面向对象的封装" aria-label="Permalink to &quot;面向对象的封装&quot;">​</a></h2><p>简易案例</p><p>需求 描述一只猫的名称，颜色，叫声，技能</p><ol><li>面向过程 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">面向过程</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var name = &quot;Tom&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var color = &quot;black&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function say() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;喵喵&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function skill() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;抓老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span></code></pre></div><ol start="2"><li>将你的需求抽象成一个对象,然后针对这个对象分析其特征(属性)与行为(方法)--这个对象就称之为类</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">字面量创建对象 (单个)</span></span>\n<span class="line"><span style="color:#F8F8F2;">   var cat = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        name: &quot;Tom&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        color: &quot;black&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        say: function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(this.name, this.color)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        },</span></span>\n<span class="line"><span style="color:#F8F8F2;">        skill: function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;抓老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span></code></pre></div><p>但是以字面量创建的对象存在一个明显的缺点,每次声明只能创建一个,无法实现代码的复用</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">var cat = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        name: &quot;Kitty&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        color: &quot;pink&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        say: function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(this.name, this.color)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        },</span></span>\n<span class="line"><span style="color:#F8F8F2;">        skill: function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;抓老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span></code></pre></div><p>解决方式 工厂模式 =&gt; 封装函数(提取参数 返回对象)</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">工厂模式  批量创建对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function cat(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        var obj = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            name: name,</span></span>\n<span class="line"><span style="color:#F8F8F2;">            color: color,</span></span>\n<span class="line"><span style="color:#F8F8F2;">            say: function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                console.log(this.name, this.color)</span></span>\n<span class="line"><span style="color:#F8F8F2;">            },</span></span>\n<span class="line"><span style="color:#F8F8F2;">            skill: function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                console.log(&quot;抓老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">            }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        return obj;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    改写形式</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function cat(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        var obj = new Object();</span></span>\n<span class="line"><span style="color:#F8F8F2;">        obj.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        obj.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        obj.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(this.name, this.color)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        obj.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;抓老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        return obj;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    var tom = cat(&quot;Tom&quot;, &quot;black&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(tom);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var Kitty = cat(&quot;Kitty&quot;, &quot;pink&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(Kitty)</span></span></code></pre></div><p>工厂模式 批量创建对象</p><ul><li><p>优点 快速得到想要的对象</p></li><li><p>缺点</p><p>(1) 通过工厂模式创建的对象跟函数没有任何关联</p><p>对比Array 非常明显</p><p>var arr = new Array(); //构造函数</p><p>console.log(arr instanceof Array); // true</p><pre><code>   (2)公用的属性和方法重复声明  需要占据多余内存\n</code></pre></li></ul><p>​ {say,skill} 两个方法重复声明 4次 占内存</p><p>解决方式 构造函数</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">function Cat(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    构造函数创建了一个原型对象(prototype)  所有的公用属性和方法 都存储在原型对象上, 每一个通过构造函数创建的对象都可以使用该原型对象的方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype.species = &quot;猫&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;捉老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this.name, this.color);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    函数调用   通过构造函数new 创建实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var Tom = new Cat(&quot;Tom&quot;, &quot;black&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(Tom);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(Tom.name);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(Tom.color);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Tom.say();   //  函数在调用的时候属于谁  就指向谁   this -&gt; Tom</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">1.  通过构造函数创建的对象和 构造函数的关联性   Tom instanceof Cat  =&gt; true;</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span></span>\n<span class="line"><span style="color:#F8F8F2;">  2.  共有的属性和方法重复声明的问题 =&gt; 怎么解决  </span></span>\n<span class="line"><span style="color:#F8F8F2;">    构造函数创建了一个原型对象(prototype)  所有的公用属性和方法 都存储在原型对象上, 每一个通过构造函数创建的对象都可以使用该原型对象的方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    注意:</span></span>\n<span class="line"><span style="color:#F8F8F2;">    prototype是一个指针，指向一个对象。这个对象的用途是，包含所有实例共享的属性和方法。</span></span>\n<span class="line"><span style="color:#F8F8F2;">	所有通过同一个构造函数创建的实例对象，都会共享同一个 prototype。</span></span>\n<span class="line"><span style="color:#F8F8F2;">    原型诞生的意义就是可以实现代码复用。</span></span></code></pre></div><h4 id="js的new关键词做了什么操作" tabindex="-1">JS的new关键词做了什么操作? <a class="header-anchor" href="#js的new关键词做了什么操作" aria-label="Permalink to &quot;JS的new关键词做了什么操作?&quot;">​</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">1、创建一个空的对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">2、链接到原型</span></span>\n<span class="line"><span style="color:#F8F8F2;">3、绑定this指向，执行构造函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">4、确保返回的是对象</span></span></code></pre></div><p>以刚刚的方法为例,new共经过了4个阶段</p><p>1、创建一个空对象</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">var obj = new Object();</span></span></code></pre></div><p>2、设置原型链（当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象）</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">obj.__proto__= Cat.prototype;</span></span></code></pre></div><p>3、让Cat中的this指向obj，并执行Cat的函数体。（创建新的对象之后，将构造函数的作用域赋给新对象（因此this就指向了这个新对象））</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">var result = Cat.call(obj);</span></span></code></pre></div><p>4、判断构造函数的返回值类型：</p><p>如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象</p><p>默认情况下函数返回值为undefined，即没有显示定义返回值的话，但构造函数例外，new构造函数在没有return的情况下默认返回新创建的对象。</p><h2 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h2><p>每个继承父函数的子函数的对象都包含一个内部属性_proto_。该属性包含一个指针，指向父函数的prototype。若父函数的原型对象的_proto_属性为再上一层函数。在此过程中就形成了原型链 .</p><p>注: 平时我们查找一个是实例化对象的属性和方法时 就是顺着原型链查找的.</p><h4 id="拓展方法" tabindex="-1">拓展方法 <a class="header-anchor" href="#拓展方法" aria-label="Permalink to &quot;拓展方法&quot;">​</a></h4><p>instanceof 判断的一个对象(实例对象)的原型链上是否包含构造函数的原型对象(prototype)</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">Tom instanceof Cat;</span></span></code></pre></div><p>isPrototypeOf 判断的是构造函数的原型对象是否存在于实例对象的原型链之上</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">Cat.prototype.isPrototypeOf(Tom)</span></span></code></pre></div><p>in 判断的一个对象(实例对象)的原型链上是否存在某个属性</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">&quot;name&quot; in Cat</span></span></code></pre></div><p>hasOwnProperty 在实例中是否包含该属性，不在原型中查找该属性</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">Tom.hasOwnProperty(&#39;name&#39;)</span></span></code></pre></div><p>propertyIsEnumerable 方法返回一个布尔值，表示指定的属性是否可枚举(遍历)。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">Tom.propertyIsEnumerable(&quot;name&quot;)</span></span></code></pre></div><h2 id="es6-构造函数-类" tabindex="-1">ES6 构造函数(类) <a class="header-anchor" href="#es6-构造函数-类" aria-label="Permalink to &quot;ES6 构造函数(类)&quot;">​</a></h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">function Cat(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }instanceof</span></span>\n<span class="line"><span style="color:#F8F8F2;">    constructor\\\\\\</span></span>\n<span class="line"><span style="color:#F8F8F2;">    constructor</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    构造函数创建了一个原型对象(prototype)  所有的公用属性和方法 都存储在原型对象上, 每一个通过构造函数创建的对象都可以使用该原型对象的方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype.species = &quot;猫&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;捉老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this.name, this.color);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    函数调用   通过构造函数new 创建实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var Tom = new Cat(&quot;Tom&quot;, &quot;black&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(Tom);</span></span></code></pre></div><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// ES6  class</span></span>\n<span class="line"><span style="color:#F8F8F2;">    class Cat {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // constructor等同于 原本的构造函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 写在此位置的方法 就行于写在  Cat.prototype  上</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 函数简写</span></span>\n<span class="line"><span style="color:#F8F8F2;">        call() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;喵喵&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        skill() {	    </span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;捉老鼠&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        say() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(this.name,this.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.dir(Cat);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var tom = new Cat(&quot;tom&quot;, &quot;black&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(tom);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    ES6 此种写法类似于 </span></span>\n<span class="line"><span style="color:#F8F8F2;">    (方便理解)</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Cat.prototype={</span></span>\n<span class="line"><span style="color:#F8F8F2;">    	constructor(){},</span></span>\n<span class="line"><span style="color:#F8F8F2;">    	call(){},</span></span>\n<span class="line"><span style="color:#F8F8F2;">    	skill(){},</span></span>\n<span class="line"><span style="color:#F8F8F2;">    	say(){}</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span></code></pre></div><h2 id="面向对象的继承" tabindex="-1">面向对象的继承 <a class="header-anchor" href="#面向对象的继承" aria-label="Permalink to &quot;面向对象的继承&quot;">​</a></h2><p>让 一个类继承(构造函数) 另一个类(构造函数) 的 属性和方法(实例化对象的属性和方法 和 原型对象prototype上的属性和方法) 或者重新定义、追加属性和方法等。</p><p>继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等</p><p>继承的类 叫做 子类 , 被继承的类 叫做 父类 。</p><p>继承主要解决的是代码重复使用的问题。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// 人</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function Person(name, age) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.age = age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.species = &quot;human&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        consoel.log(&quot;think&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        consoel.log(this.name, this.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">     // 黄种人  </span></span>\n<span class="line"><span style="color:#F8F8F2;">    function YellowPerson(hobby) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.hobby = hobby;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype.skin = &quot;yellow&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype.speak = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;chinese&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    };</span></span></code></pre></div><p>上述代码有两个类 Person 和 YellowPerson , 如何让YellowPerson 继承 Person的name,age,species属性和 skill,say方法?</p><h3 id="构造函数继承" tabindex="-1">构造函数继承 <a class="header-anchor" href="#构造函数继承" aria-label="Permalink to &quot;构造函数继承&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// 人</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function Person(name, age) { //  构造函数中 实例的属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        //  this-&gt;构造函数Person创建的实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.age = age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.species = &quot;human&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // this.__proto__ = Person.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // return this;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 原型对象上的属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this.name, this.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;thinking&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    // YellowPerson</span></span>\n<span class="line"><span style="color:#F8F8F2;">	function YellowPerson(name, age, hobby) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        //  this-&gt;构造函数YellowPerson创建的实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">        </span></span>\n<span class="line"><span style="color:#F8F8F2;">        // Person(); // 普通函数来调用   this -&gt;  window</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 我们的想法是 调用Person()函数 将Person()函数中的this指向  当前YellowPerson创建的实例化对象(this)</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 1. 执行Person()方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 2. 在Person()执行过程中 将this 只想为  当前YellowPerson创建的实例化对象(this)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        Person.call(this, name, age);</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.hobby = hobby;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    var zhangSan = new YellowPerson(&quot;张三&quot;, 18, &quot;唱&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(zhangSan)</span></span></code></pre></div><p>缺点 只能继承 父类实例的属性(name,age,species)和方法 并不能继承 父类原型对象(prototype)上的属性和方法</p><h4 id="关于call和apply" tabindex="-1">关于call和apply <a class="header-anchor" href="#关于call和apply" aria-label="Permalink to &quot;关于call和apply&quot;">​</a></h4><p>call和apply都会调 用函数 , 在函数执行过程中改变this的指向</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">call(obj,arg1,arg2...argN)  </span></span>\n<span class="line"><span style="color:#F8F8F2;">    1.  执行函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">    2.  在函数执行过程中,将该函数的this 强制指向call的第一个参数(obj)</span></span>\n<span class="line"><span style="color:#F8F8F2;">    3.  如果函数需要接收参数的话  那么在call()的第二个参数起依次向后排</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    function fn(a, b) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this, a, b); // document 10,20</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    fn.call(document, 10, 20); </span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    apply(obj,[arg1,arg2,...,argN])</span></span>\n<span class="line"><span style="color:#F8F8F2;">    1.  执行函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">    2.  在函数执行过程中, 将该函数的this 强制指向apply的第一个参数(对象)</span></span>\n<span class="line"><span style="color:#F8F8F2;">    3.  如果函数需要接收参数的话  那么在apply() 需要将参数先依次放到数组中，在将数组作为第二参数传到apply()中</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">     function fn(a, b) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this, a, b);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    fn.apply(document.body, [10, 20]);</span></span></code></pre></div><p>运用 1. 伪数组转真数组</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">var liList = document.querySelectorAll(&quot;.list li&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">list  = Array.prototype.slice(lilist);</span></span>\n<span class="line"><span style="color:#F8F8F2;">console.log(list);</span></span></code></pre></div><p>运用2. 判断一个数据是否是对象(纯Object类型的对象)</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">var obj = {};</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">Object.prototype.toString.call(obj);   // &quot;[object Object]&quot;</span></span></code></pre></div><h3 id="原型继承" tabindex="-1">原型继承 <a class="header-anchor" href="#原型继承" aria-label="Permalink to &quot;原型继承&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// 人</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function Person(name, age) { //  构造函数中 实例的属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        //  var obj = new Object();    this-&gt;构造函数Person创建的实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.age = age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.species = &quot;human&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // this.__proto__ = Person.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // return this;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 原型对象上的属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this.name, this.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;thinking&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    // YellowPerson</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    function YellowPerson(name, age, hobby) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.hobby = hobby;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype = new Person(&quot;张三&quot;, 18);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype.sayHello = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;hello&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    var zhangSan = new YellowPerson(&quot;张三&quot;, 18, &quot;唱&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(zhangSan)</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 拆分</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 1. new Person(&quot;张三&quot;, 18);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 得到一个对象 </span></span>\n<span class="line"><span style="color:#F8F8F2;">    // {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     name: &quot;张三&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     age: 18,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     hobby: &quot;human&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     __proto__: Person.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 2. YellowPerson.prototype = new Person(&quot;张三&quot;, 18);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // YellowPerson.prototype = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     name: &quot;张三&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     age: 18,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     species: &quot;human&quot;,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     __proto__: Person.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    原型链</span></span></code></pre></div><p>原型继承 通过拓宽原型链实现子类继承父类的原型对象的属性和方法</p><p>缺点 只能继承 父类原型对象上的属性和方法 ,并不能继承 父类实例的属性和方法</p><h4 id="原型继承优化-中间件继承" tabindex="-1">原型继承优化 中间件继承 <a class="header-anchor" href="#原型继承优化-中间件继承" aria-label="Permalink to &quot;原型继承优化 中间件继承&quot;">​</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// 黄种人  </span></span>\n<span class="line"><span style="color:#F8F8F2;">    function YellowPerson(name, age, hobby) {  // this -&gt;  new YellowPerson() 创建的实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.hobby = hobby;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 创建一个中间函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var Fn = function () { }   // var obj  this-&gt;obj  return this </span></span>\n<span class="line"><span style="color:#F8F8F2;">    Fn.prototype = Person.prototype;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // new Fn();  //  {__proto__:Person.prototype}</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype = new Fn();</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 方便理解</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // YellowPerson.prototype = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     __proto__: Person.prototype,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // }</span></span></code></pre></div><h3 id="组合继承" tabindex="-1">组合继承 <a class="header-anchor" href="#组合继承" aria-label="Permalink to &quot;组合继承&quot;">​</a></h3><p>构造函数继承 + 原型继承</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">// 人</span></span>\n<span class="line"><span style="color:#F8F8F2;">    function Person(name, age) { //  构造函数中 实例的属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        //  var obj = new Object();    this-&gt;构造函数Person创建的实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.age = age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.species = &quot;human&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // this.__proto__ = Person.prototype</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // return this;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 原型对象上的属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.say = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(this.name, this.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    Person.prototype.skill = function () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        console.log(&quot;thinking&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">   // 黄种人  </span></span>\n<span class="line"><span style="color:#F8F8F2;">    function YellowPerson(name, age, hobby) {  // this -&gt;  new YellowPerson() 创建的实例化对象</span></span>\n<span class="line"><span style="color:#F8F8F2;">    	Person.call(this, name, age);  // 构造函数的继承</span></span>\n<span class="line"><span style="color:#F8F8F2;">        this.hobby = hobby;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 创建一个中间函数</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var Fn = function () { }   // var obj  this-&gt;obj  return this </span></span>\n<span class="line"><span style="color:#F8F8F2;">    Fn.prototype = Person.prototype;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    // new Fn();  //  {__proto__:Person.prototype}</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype = new Fn();</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    // 方便理解</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // YellowPerson.prototype = {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    //     __proto__: Person.prototype,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    // }</span></span></code></pre></div><h3 id="es6的继承" tabindex="-1">ES6的继承 <a class="header-anchor" href="#es6的继承" aria-label="Permalink to &quot;ES6的继承&quot;">​</a></h3><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">//Person</span></span>\n<span class="line"><span style="color:#F8F8F2;">	class Person {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, age) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.age = age;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.species = &quot;human&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        skill() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            consoel.log(&quot;think&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        say() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(this.name, this.age);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span></span>\n<span class="line"><span style="color:#F8F8F2;">    //YellowPerson</span></span>\n<span class="line"><span style="color:#F8F8F2;">    class YellowPerson extends Person {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, age, hobby) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        	super(name, age); // super  作为一个函数使用代表调用父类构造函数 相当于 ES5   Person.call(this,name,age)</span></span>\n<span class="line"><span style="color:#F8F8F2;">        	this.hobby = hobby;  // 拓展自己的实例属性 / 方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">    	}</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 拓展自己的YellowPerson  的动态属性和方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        // skin = &quot;yellow&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        speak() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">             console.log(&quot;chinese&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 改写父类</span></span>\n<span class="line"><span style="color:#F8F8F2;">        say() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">             console.log(this.name, this.age, this.hobby);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    YellowPerson.prototype.skin = &quot;yellow&quot;;</span></span></code></pre></div><h4 id="super的用法归纳-了解" tabindex="-1">super的用法归纳(了解) <a class="header-anchor" href="#super的用法归纳-了解" aria-label="Permalink to &quot;super的用法归纳(了解)&quot;">​</a></h4><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">1.  super  作为一个函数使用  代表 调用父类构造函数 (作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。)</span></span>\n<span class="line"><span style="color:#F8F8F2;">    2. super 作为一个对象使用</span></span>\n<span class="line"><span style="color:#F8F8F2;">        2.1  super作为一个对象 取值的时候 super 等价于 父类的原型对象  (此案例就相当于 Person.prototype) </span></span>\n<span class="line"><span style="color:#F8F8F2;">        2.2  super作为一个对象 赋值的时候 super 等价于 this</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">class YellowPerson extends Person {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, age, hobby) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            // 1.  super  作为一个函数使用</span></span>\n<span class="line"><span style="color:#F8F8F2;">            super(name, age);  //  调用父类构造函数   ES5  Person.call(this,name,age)</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.hobby = hobby;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(super.skill);</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(super.skill === Person.prototype.skill);  //</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.x = &quot;hello&quot;;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            super.x = 123123;</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 拓展自己的动态方法</span></span>\n<span class="line"><span style="color:#F8F8F2;">        speak() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;chinese&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">        // 改写父类</span></span>\n<span class="line"><span style="color:#F8F8F2;">        say() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(this.name, this.age, this.hobby);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    var zhang = new YellowPerson(&quot;张三&quot;, 18, &quot;跳&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    console.log(zhang);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    zhang.say();</span></span></code></pre></div><h3 id="面向对象之多态" tabindex="-1">面向对象之多态 <a class="header-anchor" href="#面向对象之多态" aria-label="Permalink to &quot;面向对象之多态&quot;">​</a></h3><p>多态 不同类(构造函数)的对象 在调用同一个方法 会显示不同的结果</p><p>JS 无态,天生就支持多态</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">class Cat {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        call() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;喵喵&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    class Dog {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        call() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;旺旺&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    class Pig {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        constructor(name, color) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.name = name;</span></span>\n<span class="line"><span style="color:#F8F8F2;">            this.color = color;</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">        call() {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.log(&quot;哼哼&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    var kitty = new Cat(&quot;Kitty&quot;, &quot;pink&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var wang = new Dog(&quot;旺财&quot;, &quot;black&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    var pei = new Pig(&quot;佩奇&quot;, &quot;pink&quot;);</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    function AnimallCall(animal) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        animal.call();</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    AnimallCall(kitty);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    AnimallCall(wang);</span></span>\n<span class="line"><span style="color:#F8F8F2;">    AnimallCall(pei);</span></span></code></pre></div><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1>', 100)
  ]));
}
const ____ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  ____ as default
};
