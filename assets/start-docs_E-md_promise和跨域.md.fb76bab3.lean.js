import { _ as _export_sfc, b as r3, c as it, S as ig } from "./chunks/framework.9c9a3542.js";
const __pageData = JSON.parse('{"title":"Promise","description":"","frontmatter":{},"headers":[{"level":2,"title":"Promise的产生背景---回调函数噩梦","slug":"promise的产生背景-回调函数噩梦","link":"#promise的产生背景-回调函数噩梦","children":[]},{"level":2,"title":"Promise对象","slug":"promise对象","link":"#promise对象","children":[]},{"level":2,"title":"同源策略","slug":"同源策略","link":"#同源策略","children":[]},{"level":2,"title":"跨域访问","slug":"跨域访问","link":"#跨域访问","children":[]},{"level":2,"title":"跨域访问之CORS","slug":"跨域访问之cors","link":"#跨域访问之cors","children":[]},{"level":2,"title":"跨域访问之JSONP","slug":"跨域访问之jsonp","link":"#跨域访问之jsonp","children":[]},{"level":2,"title":"try...catch...finally","slug":"try-catch-finally","link":"#try-catch-finally","children":[]}],"relativePath":"start-docs/E-md/promise和跨域.md","filePath":"start-docs/E-md/promise和跨域.md"}');
const _sfc_main = { name: "start-docs/E-md/promise和跨域.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h1><h2 id="promise的产生背景-回调函数噩梦" tabindex="-1">Promise的产生背景---回调函数噩梦 <a class="header-anchor" href="#promise的产生背景-回调函数噩梦" aria-label="Permalink to &quot;Promise的产生背景---回调函数噩梦&quot;">​</a></h2><p>回调函数噩梦(恐怖回调)，也被称为恶魔金字塔，指如ajax依赖调用时，回调函数会层层嵌套，而这种层层嵌套的写法，往往会让人难以理解，所以称之为噩梦。</p><p>例如：服务器中有3个txt文件，我们需要在html上，通过js中的异步的ajax，分别获取这3个文件的内容，假设这3个文件分别存储的数据为1、2、3，那么我希望在js中，能够求出1+2+3，把6输出。</p><p>你觉得代码应该怎么写？</p><div class="language-js codearea-link" id="wqflh7hm1jr"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> str </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#E6DB74;">&quot;&quot;</span><span style="color:#F8F8F2;">;</span></span>\n<span class="line"><span style="color:#F8F8F2;">    $.</span><span style="color:#A6E22E;">ajax</span><span style="color:#F8F8F2;">({</span></span>\n<span class="line"><span style="color:#F8F8F2;">        type: </span><span style="color:#E6DB74;">&quot;get&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        url: </span><span style="color:#E6DB74;">&quot;../data/1.txt&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        </span><span style="color:#A6E22E;">success</span><span style="color:#F8F8F2;">: </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;font-style:italic;">msg1</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">            console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(msg1);</span></span>\n<span class="line"><span style="color:#F8F8F2;">            str </span><span style="color:#F92672;">+=</span><span style="color:#F8F8F2;"> msg1;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">            </span><span style="color:#A6E22E;">setTimeout</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> () {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                $.</span><span style="color:#A6E22E;">ajax</span><span style="color:#F8F8F2;">({</span></span>\n<span class="line"><span style="color:#F8F8F2;">                    type: </span><span style="color:#E6DB74;">&quot;get&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">                    url: </span><span style="color:#E6DB74;">&quot;../data/2.txt&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">                    </span><span style="color:#A6E22E;">success</span><span style="color:#F8F8F2;">: </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;font-style:italic;">msg2</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                        console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(msg2);</span></span>\n<span class="line"><span style="color:#F8F8F2;">                        str </span><span style="color:#F92672;">+=</span><span style="color:#F8F8F2;"> msg2;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">                        $.</span><span style="color:#A6E22E;">ajax</span><span style="color:#F8F8F2;">({</span></span>\n<span class="line"><span style="color:#F8F8F2;">                            type: </span><span style="color:#E6DB74;">&quot;get&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">                            url: </span><span style="color:#E6DB74;">&quot;../data/3.txt&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">                            </span><span style="color:#A6E22E;">success</span><span style="color:#F8F8F2;">: </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;font-style:italic;">msg3</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">                                console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(msg3);</span></span>\n<span class="line"><span style="color:#F8F8F2;">                                str </span><span style="color:#F92672;">+=</span><span style="color:#F8F8F2;"> msg3;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">                                console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(str);</span></span>\n<span class="line"><span style="color:#F8F8F2;">                            }</span></span>\n<span class="line"><span style="color:#F8F8F2;">                        })</span></span>\n<span class="line"><span style="color:#F8F8F2;">                    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">                })</span></span>\n<span class="line"><span style="color:#F8F8F2;">            }, </span><span style="color:#AE81FF;">10</span><span style="color:#F8F8F2;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">        }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    })</span></span></code></pre><button class="link">将此代码在线运行</button></div><h2 id="promise对象" tabindex="-1">Promise对象 <a class="header-anchor" href="#promise对象" aria-label="Permalink to &quot;Promise对象&quot;">​</a></h2><p>Promise是一种思维方式，是一种解决回调函数噩梦的方案(Promise 是异步编程的一种解决方案)。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>Promise对象代表一个异步操作，有三种状态：</p><ul><li>Pending（进行中）</li><li>Resolved（已完成，又称Fulfilled）</li><li>Rejected（已失败）</li></ul><p>注：可以把Promise看成是状态机，当该Promise对象创建出来之后，其状态就是进行中，然后通过程序来控制到底是执行已完成，还是执行已失败。因为Promise处理的是异步任务，所以我们还得对Promise做监听，当Promise的状态发生变化时，我们要执行相应的函数。</p><p>Promise的特点:</p><ol><li><p>对象的状态不受外界影响 =&gt; 想要改变状态 需要借助 resolve,rejected 方法 resolve() =&gt; pending(进行中状态) =&gt; fulfilled(已成功) reject() =&gt; pending(进行中状态) =&gt; rejected(已失败)</p></li><li><p>Promise 对象 的状态一经改变 不能再次改变</p></li></ol><p>Promise的优点: 优点 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数</p><p>缺点</p><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。(直接报错)</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ol><div class="language-javascript codearea-link" id="w6zggo1smfa"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">var</span><span style="color:#F8F8F2;"> promise </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">new</span><span style="color:#F8F8F2;"> </span><span style="color:#66D9EF;font-style:italic;">Promise</span><span style="color:#F8F8F2;">( </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">( </span><span style="color:#FD971F;font-style:italic;">resolve</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">reject</span><span style="color:#F8F8F2;"> ){</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#88846F;">// 通常这里写一个异步任务，在这个异步任务中，</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#88846F;">// 通过resolve或reject来改变promise的状态。</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#A6E22E;">resolve</span><span style="color:#F8F8F2;">(“数据”);</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#88846F;">// resolve指将状态更改为已完成</span></span>\n<span class="line"><span style="color:#F8F8F2;">	</span><span style="color:#88846F;">// reject指将状态更改为已失败。</span></span>\n<span class="line"><span style="color:#F8F8F2;">} );</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88846F;">// then实际上是对promise的状态监听</span></span>\n<span class="line"><span style="color:#88846F;">// 当状态为已完成时，触发第一个参数函数。</span></span>\n<span class="line"><span style="color:#88846F;">// 当状态为已失败时，触发第二个参数函数（第二个参数函数，可写可不写）</span></span>\n<span class="line"><span style="color:#88846F;">// 每一个函数中的参数，指当初状态改变时，所保存的数据。</span></span>\n<span class="line"><span style="color:#F8F8F2;">promise.</span><span style="color:#A6E22E;">then</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">str</span><span style="color:#F8F8F2;">){}, </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">err</span><span style="color:#F8F8F2;">){});</span></span>\n<span class="line"><span style="color:#88846F;">// or</span></span>\n<span class="line"><span style="color:#88846F;">// catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。(注 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。)</span></span>\n<span class="line"><span style="color:#F8F8F2;">promise.</span><span style="color:#A6E22E;">then</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">str</span><span style="color:#F8F8F2;">){}).</span><span style="color:#A6E22E;">catch</span><span style="color:#F8F8F2;">(</span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">err</span><span style="color:#F8F8F2;">){})</span></span></code></pre><button class="link">将此代码在线运行</button></div><p>all：每一个promise都执行后，再去执行then。</p><div class="language-javascript codearea-link" id="rabdsmy7zv"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">Promise</span><span style="color:#F8F8F2;">.</span><span style="color:#A6E22E;">all</span><span style="color:#F8F8F2;">( [ promise1, promise2… ] ).</span><span style="color:#A6E22E;">then</span><span style="color:#F8F8F2;">( </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">( </span><span style="color:#FD971F;font-style:italic;">result</span><span style="color:#F8F8F2;"> ){} )</span></span></code></pre><button class="link">将此代码在线运行</button></div><p>race：只要有一个promise执行后，就去执行then。</p><div class="language-javascript codearea-link" id="g14lih4yy0g"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">Promise</span><span style="color:#F8F8F2;">.</span><span style="color:#A6E22E;">race</span><span style="color:#F8F8F2;">( [ promise1, promise2… ] ).</span><span style="color:#A6E22E;">then</span><span style="color:#F8F8F2;">( </span><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;">( </span><span style="color:#FD971F;font-style:italic;">result</span><span style="color:#F8F8F2;"> ){} )</span></span></code></pre><button class="link">将此代码在线运行</button></div><h1 id="跨域" tabindex="-1">跨域 <a class="header-anchor" href="#跨域" aria-label="Permalink to &quot;跨域&quot;">​</a></h1><p>一个网站访问另一个网站的数据.</p><h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><p>同源策略：同源策略（Same origin policy）是一种约定,它是浏览器最核心也最基本的安全功能,由客户端访问某一个服务器的文件时，如果发起请求的这个来源与进行响应的目标的源不一致，目标源出于安全的角度，将拒绝这次访问。</p><p>同源策略限制了从同一个源(网站)加载的文档或脚本如何与来自另一个源(网站)的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>比如，我们网站想从别人网站中拿一些数据，那么默认的时候，别人网站是不会给我们数据的。</p><p>协议名、域名、端口，这三项都相同，则被称为同源。 三项中只要有一项不同，则被称为跨源。</p><p>协议名指http、https等这种 域名包含网站域名、ip地址、计算机名称 端口默认是80，80并不会显示在浏览器地址栏中</p><div class="language-txt"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;"># 下面哪组网址跨源（跨域）了？</span></span>\n<span class="line"><span style="color:#F8F8F2;">http://127.0.0.1/1.html			http://127.0.0.1/2.html</span></span>\n<span class="line"><span style="color:#F8F8F2;">http://127.0.0.1:80/1.html		http://127.0.0.1</span></span>\n<span class="line"><span style="color:#F8F8F2;">http://127.0.0.1/               http://localhost/</span></span>\n<span class="line"><span style="color:#F8F8F2;">http://localhost:81/1.html		http://localhost:82/1.html</span></span>\n<span class="line"><span style="color:#F8F8F2;">http://abc.com/                 http://mp3.abc.com/</span></span>\n<span class="line"><span style="color:#F8F8F2;">http://mp3.abc.com/			    https://mp3.abc.com/</span></span></code></pre></div><p>跨源访问也叫做跨域访问。</p><p>真实开发中，很多场景下会涉及到跨域访问，比如百度网站就特别大，其中有mp3.baidu.com、image.baidu.com、tieba.baidu.com等等，而其中一些数据或服务是需要共用的，所以就需要跨域访问。</p><p>再比如支付系统，各个电商网站都提供支付宝或微信付款，这个就需要用到支付宝或微信的接口，所以这也是跨域访问。</p><p>那么，如何进行跨域访问呢？</p><h2 id="跨域访问" tabindex="-1">跨域访问 <a class="header-anchor" href="#跨域访问" aria-label="Permalink to &quot;跨域访问&quot;">​</a></h2><p>AJAX解决的是数据交互问题，即把数据传递给对方，把对方的数据拿回来。 但有时对方网站因同源策略的限制，拒绝我们的请求，不给我们数据，所以我们需要想办法解决这个问题。</p><p>解决跨域访问的方法：</p><ul><li>对方服务器CORS(跨域资源共享 )</li></ul><blockquote><p>指在对方服务器上做配置，即让他们允许我们访问，这样我们再通过AJAX就可以拿到数据了。</p></blockquote><ul><li>我方客户端JSONP(原理 引入资源不受同源策略的限制 link的href script的src img的src )</li></ul><blockquote><p>JSONP和AJAX一样，也是一种数据交互的方式。</p></blockquote><blockquote><p>无论对方网站是否允许我们访问，我们直接通过script标签，访问对方文件，拿到对方数据。</p></blockquote><p>AJAX和JSONP都可以做数据交互，当有这种需求时，我们应该在AJAX和JSONP中选择一种。</p><ul><li><p>如果拿回来的响应内容，被一个函数包裹着，可以用JSONP处理。</p></li><li><p>如果拿回来的响应内容，没有被函数包裹，可以用AJAX处理。</p></li></ul><h2 id="跨域访问之cors" tabindex="-1">跨域访问之CORS <a class="header-anchor" href="#跨域访问之cors" aria-label="Permalink to &quot;跨域访问之CORS&quot;">​</a></h2><p>CORS指跨域资源共享</p><div class="language-php"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F92672;">&lt;?</span><span style="color:#AE81FF;">php</span></span>\n<span class="line"><span style="color:#88846F;">// 下面这句话指允许来至任何人的访问</span></span>\n<span class="line"><span style="color:#66D9EF;">header</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&#39;Access-Control-Allow-Origin: *&#39;</span><span style="color:#F8F8F2;">);  </span></span>\n<span class="line"><span style="color:#88846F;">// 允许特定的网址来访问</span></span>\n<span class="line"><span style="color:#66D9EF;">header</span><span style="color:#F8F8F2;">(</span><span style="color:#AE81FF;">‘Access</span><span style="color:#F92672;">-</span><span style="color:#AE81FF;">Control</span><span style="color:#F92672;">-</span><span style="color:#AE81FF;">Allow</span><span style="color:#F92672;">-</span><span style="color:#AE81FF;">Origin</span><span style="color:#F8F8F2;">:</span><span style="color:#AE81FF;">http</span><span style="color:#F8F8F2;">:</span><span style="color:#88846F;">//127.0.0.1:8020’); </span></span>\n<span class="line"><span style="color:#F92672;">?&gt;</span></span></code></pre></div><h2 id="跨域访问之jsonp" tabindex="-1">跨域访问之JSONP <a class="header-anchor" href="#跨域访问之jsonp" aria-label="Permalink to &quot;跨域访问之JSONP&quot;">​</a></h2><p>因为script标签支持跨域访问，所以我们可以创建script标签，src指向一个跨域文件。</p><p>那么，该跨域文件的响应内容，就变成script标签内的内容了。</p><p>所以，该内容也可以被理解成是正在被执行的js代码。</p><p>如果该代码中有一个正在被执行的函数，该函数中又有参数。</p><p>我们就可以把这个参数理解成服务器传给客户端的数据。</p><p>客户端去定义这个函数，我们就能够对参数做任意处理了</p><h2 id="try-catch-finally" tabindex="-1">try...catch...finally <a class="header-anchor" href="#try-catch-finally" aria-label="Permalink to &quot;try...catch...finally&quot;">​</a></h2><p>try/catch/finally 语句用于处理代码中可能出现的错误信息。</p><p>错误可能是语法错误，通常是程序员造成的编码错误或错别字。也 可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。</p><p>try语句允许我们定义在执行时进行错误测试的代码块。</p><p>catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。</p><p>finally 语句在 try 和 catch 之后无论有无异常都会执行。</p><p>注意： catch 和 finally 语句都是可选的，但你在使用 try 语句时必须至少使用一个。</p><p>提示： 当错误发生时， JavaScript 会停止执行，并生成一个错误信息。使用 throw 语句 来创建自定义消息(抛出异常)。如果你将 throw 和 try 、 catch一起使用，就可以控制程序输出的错误信息。</p><div class="language-js codearea-link" id="go2bvx7hoz"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#F92672;">try</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        tryCode </span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;"> 尝试执行代码块</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">catch</span><span style="color:#F8F8F2;"> (err) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        catchCode </span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;"> 捕获错误的代码块</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">finally</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        finallyCode </span><span style="color:#F92672;">-</span><span style="color:#F8F8F2;"> 无论 </span><span style="color:#F92672;">try</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">/</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">catch</span><span style="color:#F8F8F2;"> 结果如何都会执行的代码块</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span></code></pre><button class="link">将此代码在线运行</button></div><p>错误类型</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;">Error    通用错误</span></span>\n<span class="line"><span style="color:#F8F8F2;"></span></span>\n<span class="line"><span style="color:#F8F8F2;">    EvalError</span></span>\n<span class="line"><span style="color:#F8F8F2;">        与eval()有关， 当调用 eval() 失败时抛出。</span></span>\n<span class="line"><span style="color:#F8F8F2;">    RangeError</span></span>\n<span class="line"><span style="color:#F8F8F2;">        数值变量或参数超出了其有效范围</span></span>\n<span class="line"><span style="color:#F8F8F2;">    ReferenceError</span></span>\n<span class="line"><span style="color:#F8F8F2;">        一个无效的引用(eg: strict模式下引用了一个未声明的变量等)</span></span>\n<span class="line"><span style="color:#F8F8F2;">    SyntaxError</span></span>\n<span class="line"><span style="color:#F8F8F2;">        当 JavaScript 语法错误时抛出。</span></span>\n<span class="line"><span style="color:#F8F8F2;">    TypeError</span></span>\n<span class="line"><span style="color:#F8F8F2;">        变量或参数不属于有效类型</span></span></code></pre></div>', 66)
  ]));
}
const promise___ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  promise___ as default
};
