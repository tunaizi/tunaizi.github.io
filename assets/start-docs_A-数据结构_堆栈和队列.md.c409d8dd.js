import { _ as _export_sfc, r as r3, i as it, w as ig } from "./chunks/framework.4a4ad33e.js";
const __pageData = JSON.parse('{"title":"堆栈与队列","description":"","frontmatter":{},"headers":[],"relativePath":"start-docs/A-数据结构/堆栈和队列.md","filePath":"start-docs/A-数据结构/堆栈和队列.md"}');
const _sfc_main = { name: "start-docs/A-数据结构/堆栈和队列.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="堆栈与队列" tabindex="-1">堆栈与队列 <a class="header-anchor" href="#堆栈与队列" aria-label="Permalink to &quot;堆栈与队列&quot;">​</a></h1><h1 id="堆栈stack和队列quene" tabindex="-1">堆栈stack和队列quene <a class="header-anchor" href="#堆栈stack和队列quene" aria-label="Permalink to &quot;堆栈stack和队列quene&quot;">​</a></h1><ul><li>stack 先进后出</li><li>quene 先进先出 （特殊：双端队列）</li></ul><ol><li>判断括号字符是否有效 使用stack</li><li>用队列实现栈&amp;用栈实现队列</li></ol><h1 id="优先队列" tabindex="-1">优先队列 <a class="header-anchor" href="#优先队列" aria-label="Permalink to &quot;优先队列&quot;">​</a></h1><ul><li>一般使用堆heap或者二叉搜索树binary search tree</li><li>小顶堆或者大顶堆</li></ul><ol><li>返回数据流中的第K大的元素</li><li>返回滑动窗口中的最大值</li></ol>', 7)
  ]));
}
const _____ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _____ as default
};
