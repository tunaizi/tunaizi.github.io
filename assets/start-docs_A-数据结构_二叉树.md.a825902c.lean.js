import { _ as _export_sfc, r as r3, i as it, a as ig } from "./chunks/framework.e6716b1e.js";
const _imports_0 = "/assets/ercha.5599a685.png";
const _imports_1 = "/assets/qianxu.a9d270c5.png";
const _imports_2 = "/assets/zhongxu.bcc3c593.png";
const _imports_3 = "/assets/houxu.cecd0e0c.png";
const __pageData = JSON.parse('{"title":"二叉树","description":"","frontmatter":{},"headers":[{"level":2,"title":"二叉树的定义","slug":"二叉树的定义","link":"#二叉树的定义","children":[]},{"level":2,"title":"二叉树的性质","slug":"二叉树的性质","link":"#二叉树的性质","children":[]},{"level":2,"title":"二叉树的类型","slug":"二叉树的类型","link":"#二叉树的类型","children":[]},{"level":2,"title":"树是特殊的图形 验证二叉搜索树","slug":"树是特殊的图形-验证二叉搜索树","link":"#树是特殊的图形-验证二叉搜索树","children":[]},{"level":2,"title":"二叉树的最近公共祖先","slug":"二叉树的最近公共祖先","link":"#二叉树的最近公共祖先","children":[]},{"level":2,"title":"二叉树遍历","slug":"二叉树遍历","link":"#二叉树遍历","children":[]},{"level":2,"title":"什么是波兰表达式","slug":"什么是波兰表达式","link":"#什么是波兰表达式","children":[]}],"relativePath":"start-docs/A-数据结构/二叉树.md","filePath":"start-docs/A-数据结构/二叉树.md"}');
const _sfc_main = { name: "start-docs/A-数据结构/二叉树.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return r3(), it("div", null, _cache[0] || (_cache[0] = [
    ig('<h1 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h1><h2 id="二叉树的定义" tabindex="-1">二叉树的定义 <a class="header-anchor" href="#二叉树的定义" aria-label="Permalink to &quot;二叉树的定义&quot;">​</a></h2><p>二叉树是一种特殊的树结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树在计算机科学中有广泛的应用，包括数据存储、查找和排序等。 二叉树是一种递归定义的数据结构。一棵二叉树可以是空的，或者由一个根节点和两棵互不相交的左子树和右子树组成。</p><h2 id="二叉树的性质" tabindex="-1">二叉树的性质 <a class="header-anchor" href="#二叉树的性质" aria-label="Permalink to &quot;二叉树的性质&quot;">​</a></h2><ol><li><p><strong>节点数</strong>:</p><ul><li>如果一棵二叉树的深度为 h，则该二叉树最多有 (2^h - 1) 个节点。</li><li>如果一棵二叉树有 n 个节点，则其深度至少为 (\\lceil \\log_2(n+1) \\rceil)。</li></ul></li><li><p><strong>满二叉树</strong>:</p><ul><li>所有层都被完全填满的二叉树。</li></ul></li><li><p><strong>完全二叉树</strong>:</p><ul><li>除了最后一层外，其他层都被完全填满，并且最后一层的节点都尽可能靠左。</li></ul></li></ol><h2 id="二叉树的类型" tabindex="-1">二叉树的类型 <a class="header-anchor" href="#二叉树的类型" aria-label="Permalink to &quot;二叉树的类型&quot;">​</a></h2><ol><li><p><strong>满二叉树</strong>:</p><ul><li>所有层都被完全填满的二叉树。</li></ul></li><li><p><strong>完全二叉树</strong>:</p><ul><li>除了最后一层外，其他层都被完全填满，并且最后一层的节点都尽可能靠左。</li></ul></li><li><p><strong>平衡二叉树</strong>:</p><ul><li>每个节点的左右子树的高度差不超过 1。</li></ul></li></ol><p><strong>图形就是含有环形的链表，常用判断最优路径</strong></p><h2 id="树是特殊的图形-验证二叉搜索树" tabindex="-1">树是特殊的图形 验证二叉搜索树 <a class="header-anchor" href="#树是特殊的图形-验证二叉搜索树" aria-label="Permalink to &quot;树是特殊的图形 验证二叉搜索树&quot;">​</a></h2><ul><li>做一次中序遍历 时间复杂度 o(n)<div class="language-js codearea-link" id="kwi31w15hz"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">isValisBST</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">root</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> stack </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> []</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">let</span><span style="color:#F8F8F2;"> inorder </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">-</span><span style="color:#AE81FF;">Infinity</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">while</span><span style="color:#F8F8F2;"> (root </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">||</span><span style="color:#F8F8F2;"> stack.length) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">while</span><span style="color:#F8F8F2;"> (root </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      stack.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(root)</span></span>\n<span class="line"><span style="color:#F8F8F2;">      root </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> root.left</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    root </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> stack.</span><span style="color:#A6E22E;">pop</span><span style="color:#F8F8F2;">()</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (root.val </span><span style="color:#F92672;">&lt;=</span><span style="color:#F8F8F2;"> inorder) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">false</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">    inorder </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> root.val</span></span>\n<span class="line"><span style="color:#F8F8F2;">    root </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> root.right</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">true</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div></li><li>递归 时间复杂度 o(n)<div class="language-js codearea-link" id="0au3oh2u9pel"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">isValidBST</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">root</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">min</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">-</span><span style="color:#AE81FF;">Infinity</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">max</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">Infinity</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> (</span></span>\n<span class="line"><span style="color:#F8F8F2;">    root </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">||</span></span>\n<span class="line"><span style="color:#F8F8F2;">    (root.val </span><span style="color:#F92672;">&gt;</span><span style="color:#F8F8F2;"> min </span><span style="color:#F92672;">&amp;&amp;</span></span>\n<span class="line"><span style="color:#F8F8F2;">      root.val </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> max </span><span style="color:#F92672;">&amp;&amp;</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#A6E22E;">isValidBST</span><span style="color:#F8F8F2;">(root.left, min, root.val) </span><span style="color:#F92672;">&amp;&amp;</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#A6E22E;">isValidBST</span><span style="color:#F8F8F2;">(root.right, root.val, max))</span></span>\n<span class="line"><span style="color:#F8F8F2;">  )</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div></li></ul><h2 id="二叉树的最近公共祖先" tabindex="-1">二叉树的最近公共祖先 <a class="header-anchor" href="#二叉树的最近公共祖先" aria-label="Permalink to &quot;二叉树的最近公共祖先&quot;">​</a></h2><p>在二叉树中查找两个节点的最近公共祖先，可以使用递归的方法。具体步骤如下：</p><ol><li>如果当前节点为空，返回 <code>null</code>。</li><li>如果当前节点是 <code>p</code> 或 <code>q</code>，返回当前节点。</li><li>递归查找左子树和右子树。</li><li>如果左子树和右子树都找到了 <code>p</code> 或 <code>q</code>，则当前节点为最近公共祖先。</li><li>如果只有一边找到了 <code>p</code> 或 <code>q</code>，则返回找到的那个节点。</li></ol><div class="language-js codearea-link" id="vla3or80qwd"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">lowestCommonAncestor</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">root</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">p</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">q</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (root </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">||</span><span style="color:#F8F8F2;"> root </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> p </span><span style="color:#F92672;">||</span><span style="color:#F8F8F2;"> root </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> q) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> root</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> left </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">lowestCommonAncestor</span><span style="color:#F8F8F2;">(root.left, p, q)</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> right </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">lowestCommonAncestor</span><span style="color:#F8F8F2;">(root.right, p, q)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (left </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">&amp;&amp;</span><span style="color:#F8F8F2;"> right </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> root </span><span style="color:#88846F;">// p 和 q 分别在左右子树中</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> left </span><span style="color:#F92672;">!==</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;"> </span><span style="color:#F92672;">?</span><span style="color:#F8F8F2;"> left </span><span style="color:#F92672;">:</span><span style="color:#F8F8F2;"> right </span><span style="color:#88846F;">// 返回非空的子树结果</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div><h2 id="二叉树遍历" tabindex="-1">二叉树遍历 <a class="header-anchor" href="#二叉树遍历" aria-label="Permalink to &quot;二叉树遍历&quot;">​</a></h2><div class="language-js codearea-link" id="9mew3cmkp3q"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> binaryTree </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  C: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#E6DB74;">&#39;A&#39;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#E6DB74;">&#39;F&#39;</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  A: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#E6DB74;">&#39;B&#39;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  B: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#E6DB74;">&#39;G&#39;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  F: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#E6DB74;">&#39;E&#39;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#E6DB74;">&#39;H&#39;</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  E: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  H: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  G: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#88846F;">// 定义一个函数将扁平化结构转换为嵌套结构</span></span>\n<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">flattenToNested</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">binaryTree</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">rootKey</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (</span><span style="color:#F92672;">!</span><span style="color:#F8F8F2;">binaryTree[rootKey]) </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> node </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> binaryTree[rootKey]</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">return</span><span style="color:#F8F8F2;"> {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    value: rootKey,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    left: </span><span style="color:#A6E22E;">flattenToNested</span><span style="color:#F8F8F2;">(binaryTree, node.left),</span></span>\n<span class="line"><span style="color:#F8F8F2;">    right: </span><span style="color:#A6E22E;">flattenToNested</span><span style="color:#F8F8F2;">(binaryTree, node.right)</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(JSON.</span><span style="color:#A6E22E;">stringify</span><span style="color:#F8F8F2;">(</span><span style="color:#A6E22E;">flattenToNested</span><span style="color:#F8F8F2;">(binaryTree, </span><span style="color:#E6DB74;">&#39;C&#39;</span><span style="color:#F8F8F2;">), </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">, </span><span style="color:#AE81FF;">2</span><span style="color:#F8F8F2;">))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F8F8F2;">{</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;C&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;A&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;B&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">        </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;G&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">        </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">      },</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">    },</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">  },</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;F&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;E&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">    },</span></span>\n<span class="line"><span style="color:#F8F8F2;">    </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: {</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;value&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#E6DB74;">&quot;H&quot;</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;left&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">,</span></span>\n<span class="line"><span style="color:#F8F8F2;">      </span><span style="color:#E6DB74;">&quot;right&quot;</span><span style="color:#F8F8F2;">: </span><span style="color:#AE81FF;">null</span></span>\n<span class="line"><span style="color:#F8F8F2;">    }</span></span>\n<span class="line"><span style="color:#F8F8F2;">  }</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div><p><img src="' + _imports_0 + '" alt="二叉树"></p><ol><li><p><strong>前序遍历（Pre-order）</strong>:</p><ul><li>顺序：根节点 -&gt; 左子树 -&gt; 右子树。</li><li>优势：适用于复制树结构，生成前缀表达式。</li><li>劣势：不适合查找特定节点。</li></ul><div class="language-js codearea-link" id="i81hl05s8mq"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">preOrderTraversal</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (node </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) </span><span style="color:#F92672;">return</span></span>\n<span class="line"><span style="color:#F8F8F2;">  console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(node.value) </span><span style="color:#88846F;">// 访问根节点</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">preOrderTraversal</span><span style="color:#F8F8F2;">(node.left) </span><span style="color:#88846F;">// 遍历左子树</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">preOrderTraversal</span><span style="color:#F8F8F2;">(node.right) </span><span style="color:#88846F;">// 遍历右子树</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div></li></ol><p><img src="' + _imports_1 + '" alt="二叉树前序遍历"></p><ol start="2"><li><p><strong>中序遍历（In-order）</strong>:</p><ul><li>顺序：左子树 -&gt; 根节点 -&gt; 右子树。</li><li>优势：对于二叉搜索树（BST），按升序访问节点。</li><li>劣势：不适合查找特定节点。</li></ul><div class="language-js codearea-link" id="rxz8gxi4ewg"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">inOrderTraversal</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (node </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) </span><span style="color:#F92672;">return</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">inOrderTraversal</span><span style="color:#F8F8F2;">(node.left) </span><span style="color:#88846F;">// 遍历左子树</span></span>\n<span class="line"><span style="color:#F8F8F2;">  console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(node.value) </span><span style="color:#88846F;">// 访问根节点</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">inOrderTraversal</span><span style="color:#F8F8F2;">(node.right) </span><span style="color:#88846F;">// 遍历右子树</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div><p><img src="' + _imports_2 + '" alt="二叉树中序遍历"></p></li><li><p><strong>后序遍历（Post-order）</strong>:</p><ul><li>顺序：左子树 -&gt; 右子树 -&gt; 根节点。</li><li>优势：适用于删除树结构，生成后缀表达式。</li><li>劣势：不适合查找特定节点。</li></ul><div class="language-js codearea-link" id="wxsm8u0dm9d"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#F8F8F2;"> </span><span style="color:#A6E22E;">postOrderTraversal</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">node</span><span style="color:#F8F8F2;">) {</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#F92672;">if</span><span style="color:#F8F8F2;"> (node </span><span style="color:#F92672;">===</span><span style="color:#F8F8F2;"> </span><span style="color:#AE81FF;">null</span><span style="color:#F8F8F2;">) </span><span style="color:#F92672;">return</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">postOrderTraversal</span><span style="color:#F8F8F2;">(node.left) </span><span style="color:#88846F;">// 遍历左子树</span></span>\n<span class="line"><span style="color:#F8F8F2;">  </span><span style="color:#A6E22E;">postOrderTraversal</span><span style="color:#F8F8F2;">(node.right) </span><span style="color:#88846F;">// 遍历右子树</span></span>\n<span class="line"><span style="color:#F8F8F2;">  console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(node.value) </span><span style="color:#88846F;">// 访问根节点</span></span>\n<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre><button class="link">将此代码在线运行</button></div><p><img src="' + _imports_3 + '" alt="二叉树后序遍历"></p></li></ol><ul><li>常用： 广度优先遍历&amp;深度优先遍历</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki monokai"><code><span class="line"><span style="color:#F8F8F2;"></span></span></code></pre></div><h2 id="什么是波兰表达式" tabindex="-1">什么是波兰表达式 <a class="header-anchor" href="#什么是波兰表达式" aria-label="Permalink to &quot;什么是波兰表达式&quot;">​</a></h2><p>波兰表达式也称为前缀表达式，逆波兰表达式也称为后缀表达式。以表达式 (1 + 2) * (3 + 4) 为例，这个表达式称为中缀表达式。</p><table><thead><tr><th style="text-align:left;">表达</th><th style="text-align:left;">描述</th><th style="text-align:center;">结果</th></tr></thead><tbody><tr><td style="text-align:left;">前缀表达式</td><td style="text-align:left;">不含括号的的算数表达式，将运算符写在前面，操作数写在后面</td><td style="text-align:center;">* + 1 2 + 3 4</td></tr><tr><td style="text-align:left;">中缀表达式</td><td style="text-align:left;">必须含括号，操作符处于操作数的中间</td><td style="text-align:center;">( 1 + 2 ) * ( 3 + 4 )</td></tr><tr><td style="text-align:left;">后缀表达式</td><td style="text-align:left;">不含括号，运算符放在两个运算对象的后面。</td><td style="text-align:center;">1 2 + 3 4 + *</td></tr></tbody></table><p>参考链接：[<a href="https://blog.csdn.net/zcs425171513/article/details/118310303" target="_blank" rel="noreferrer">https://blog.csdn.net/zcs425171513/article/details/118310303</a>]</p>', 26)
  ]));
}
const ___ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  ___ as default
};
